const axios = require('axios').default;
const helpers = require('./helpers');
const path = require('path');
const url = require('url');

module.exports = {
	createSessionFromTemplate: createSessionFromTemplate,
	createSessionFromTemplateAndWait: createSessionFromTemplateAndWait
}

/**
 * Verify that the timeout for completing the
 * test session was not exceeded.
 * */
function checkForTimeout(startTime, timeoutSec) {
	if (Date.now() - startTime > timeoutSec * 1000) {
		console.log(`Timeout of ${timeoutSec} seconds exceeded while waiting for test session to complete`);
		process.exit(1);
	}
}

/**
 * Count the total number of tests that have the
 * specified result.
 */
function countTestsWithResult(tests, result) {
	var total = 0;

	tests.forEach(function (test) {
		if (!test.isDataDriven) {
			if (test.result == result) {
				total++;
			}
		} else {
			test.subtests.forEach(function (test) {
				if (test.result == result) {
					total++;
				}
			});
		}
	});

	return total;
}

/**
 * Create a new test session from a template file and return a promise
 * that resolves to the session ID. */
function createSessionFromTemplate(templatePartialPath, syncServerUrl) {
	syncServerUrl = syncServerUrl || 'http://localhost:3000';

	const reqOptions = {
		url: url.resolve(syncServerUrl, 'api/session'),
		method: 'POST',
		data: {
			template: {
				name: path.basename(templatePartialPath, path.extname(templatePartialPath)),
				path: path.dirname(templatePartialPath)
			}
		}
	};

	return new Promise(function (resolve, reject) {
		axios(reqOptions)
			.then(function (res) {
				const sessionId = res.data.sessionId;
				console.log("Started test session " + sessionId);
				resolve(sessionId);
			})
			.catch(function (err) {
				console.log('Error: ', err.message);
				if (err.response && err.response.data) {
					console.log('Response payload: ', err.response.data);
				}
				reject(err);
			});
	});
}

/**
 * Create a new test session from a template file and waits for the test
 * session to complete before returning. */
function createSessionFromTemplateAndWait(templatePartialPath, syncServerUrl, timeout) {
	syncServerUrl = syncServerUrl || 'http://localhost:3000';

	createSessionFromTemplate(templatePartialPath, syncServerUrl)
		.then(function (sessionId) {
			let startTime = Date.now();

			console.log(`Session completion timeout was set to ${timeout} seconds`);
			console.log(`Waiting for the test session to complete...`);

			// Check the test session status periodically, until the test
			// session is complete or the configured timeout expires
			setInterval(function () {
				exitIfSessionCompleted(sessionId, startTime, timeout);
			}, 5000);
		})
		.catch(function (err) {
			process.exit(1);
		});
}

function getTestSessionInfo(sessionId, syncServerUrl) {
	syncServerUrl = syncServerUrl || 'http://localhost:3000';

	const reqOptions = {
		url: url.resolve(syncServerUrl, `api/session/${sessionId}`),
		method: 'GET'
	};

	return new Promise(function (resolve, reject) {
		axios(reqOptions)
			.then(function (res) {
				resolve(res.data);
			})
			.catch(function (err) {
				reject(err);
			});
	});
}

function exitIfSessionCompleted(sessionId, startTime, timeoutSec, syncServerUrl) {
	if (Date.now() - startTime > timeoutSec * 1000) {
		console.log(`Timeout of ${timeoutSec} seconds exceeded while waiting for test session to complete`);
		process.exit(1);
	}

	syncServerUrl = syncServerUrl || 'http://localhost:3000';

	getTestSessionInfo(sessionId)
		.then(function (sessionInfo) {
			if (sessionInfo.status == 'completed') {
				if (sessionInfo.result == 'passed') {
					var passed = countTestsWithResult(sessionInfo.tests, "passed");

					console.log(`${passed} test(s) passed`);
					console.log(`Test session completed successfully`);

					process.exit(0);
				} else {
					console.log(`${sessionInfo.testCounts.passed} test(s) passed`);
					console.log(`${sessionInfo.testCounts.failed} test(s) failed`);
					console.log(`Test session failed`);

					console.log(
						'\nThe failed tests were:\n' +
						sessionInfo.tests
							.filter((t) => { return t.result != 'passed'; })
							.map((t) => {
								return '    ' + helpers.trimChars(t.path.trim() + '/' + t.name.trim(), '/');
							})
							.join('\n'));
					const sessionInfoUrl = url.resolve(syncServerUrl, 'session/' + sessionId);
					console.log('\nFor additional information go to ' + sessionInfoUrl);
					process.exit(1);
				}
			}
		})
		.catch(function (err) {
			console.log('Error: ', err);
			process.exit(1);
		});
}