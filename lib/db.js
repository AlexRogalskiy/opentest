var rek = require('rekuire');
var constants = rek('lib/constants');
var helpers = rek('lib/helpers');
var moment = require('moment'); 
var util = require('util');

var db;
reset();

function deleteActorSync(actorId) {
    Object.keys(db.actors).forEach(function(key) {
        if(actorId === db.actors[key].id) {
            delete db.actors[key];
        }
    });
}

function findActorsByTypeSync(actorType) {
    var actors = [];
    if (typeof actorType === 'string') {
        actorType = actorType.trim().toUpperCase();
    }

    Object.keys(db.actors).forEach(function(key) {
        if(!actorType || actorType === db.actors[key].type) {
            actors.push(db.actors[key]);
        }
    });

    return actors;
}

function insertActorSync(actorId, actorType) {
    if (!db.actors[actorId]) {
        db.actors[actorId] =  {
            id: actorId,
            lastSeenTime: Date.now(),
            testSessionId: null,
            type: actorType
        };
    } else {
        throw new Error(util.format('Actor ID %s already exists',
            actorId)); 
    }
}

function insertSessionSync(sessionId) {
    if (!db.testSessions[sessionId]) {
        db.testSessions[sessionId] =  {
            id: sessionId,
            actors: {},
            currentTestIndex: 0,
            currentStepIndex: 0,
            result: constants.testSessionResult.PENDING,
            status: constants.testSessionStatus.ACQUIRING_ACTORS,
            tests: [],
            timeCreated: Date.now(),
            timeStarted: null,
            timeCompleted: null
        };
    } else {
        throw new Error(util.format('Test session %s already exists',
            sessionId));
    }
}

function insertTestDefSync(sessionId, testId) {
    if (!db.tests[testId]) {
        var test = {
            sessionId: sessionId,
            testId: testId,
            timeStarted: null,
            timeCompleted: null,
            currentStepIndex: 0,
            actors: {},
            testData: {},
            steps: {}
        };
        
        db.tests[testId] = test;
    } else {
        throw new Error(util.format('Test %s already exists in session %s',
            testId,
            sessionId));
    }
}

function getActorSync(actorId) {
    return helpers.clone(db.actors[actorId]);
}

function getSessionSync(sessionId) {
    if (db.testSessions[sessionId]) {
        return db.testSessions[sessionId];
    } else {
        return null;
    }
}

function getSessionsSync() {
    var sessions = [];
    var currentSession;

    Object.keys(db.testSessions).forEach(function(sessionId) {
        currentSession = db.testSessions[sessionId];
        sessions.push(currentSession);
    });
    
    return sessions.sort(function(a, b) {
        if (a.timeStarted > b.timeStarted) {
            return 1;
        } else  if (a.timeStarted < b.timeStarted) {
            return -1;
        } else {
            return 0;
        }
    });
}

function getTestSync(sessionId, testName) {
    var testId = getTestId(sessionId, testName);
    var test = db.tests[testId];
    
    if (!test) {
        throw new Error('Test not found');
    }
    
    return test;
}

function getTestId(testGroup, testName) {
    return util.format('%s.%s', testGroup, testName);
}

function getTestsSync() {
    return db.tests;
}

function getStepStatusSync(sessionId, testIndex, stepIndex) {
    var testId = getTestId(sessionId, testName);
    var test = getTestSync(sessionId, testName);
    
    if (test.steps[stepIndex]) {
        return test.steps[stepIndex].status;
    } else {
        throw new Error(util.format('Step %s for test %s was not found',
            stepIndex,
            testId));        
    }
}

// Updates the current test index and current step inxed for a session 
// based on the status reported by actors for the current test step
function refreshSession(sessionId) {
    var testSession = db.testSessions[sessionId];

    // Check if the current step for the current test was completed on all actors
    var currentStepWasCompleted = true;
    var currentStepPassed = true;

    var actorIds = Object.keys(testSession.actors);
    var actor, actorTest, step;

    for (var actorIdIndex = 0; actorIdIndex < actorIds.length; ++actorIdIndex) {
        actor = testSession.actors[actorIds[actorIdIndex]];
        actorTest = actor.tests[testSession.currentTestIndex];

        if (actorTest && actorTest.steps) {
            step = actorTest.steps[testSession.currentStepIndex];

            if (!step) {
                currentStepWasCompleted = false;
                currentStepPassed = false;
                break;
            } else {
                if (step.status !== constants.stepStatus.COMPLETED) {
                    currentStepWasCompleted = false;
                    currentStepPassed = false;
                } else {
                    currentStepPassed = (step.result === constants.stepResult.PASSED);
                }
            }
        } else {
            currentStepWasCompleted = false;
        }
    }

    var currentTestDef = testSession.tests[testSession.currentTestIndex];
    var lastStepDef = currentTestDef.steps[currentTestDef.steps.length - 1];

    // Check if the last step for the current test was completed and advance to the next test
    if (currentStepWasCompleted) {
        var currentTest =  testSession.tests[testSession.currentTestIndex];
        var currentStep = currentTest.steps[testSession.currentStepIndex];

        currentStep.status = constants.stepStatus.COMPLETED;
        currentStep.result = currentStepPassed ? constants.stepResult.PASSED : constants.stepResult.FAILED;
        currentStep.timeCompleted = Date.now();

        var reachedLastStep = (testSession.currentStepIndex >= lastStepDef.index);
        var reachedLastTest = testSession.currentTestIndex >= testSession.tests.length - 1;
        
        if (reachedLastStep || !currentStepPassed) {
            currentTest.status = constants.testStatus.COMPLETED;
            currentTest.result = currentStepPassed ? constants.testResult.PASSED : constants.testResult.FAILED;
            currentTest.timeCompleted = Date.now();

            if (!reachedLastTest) {
                ++testSession.currentTestIndex;
                testSession.currentStepIndex = 0;
            } else {
                testSession.status = constants.testSessionStatus.COMPLETED;
                testSession.timeCompleted = Date.now();

                // Reset actors
                var actorIds = Object.keys(testSession.actors);
                actorIds.forEach(function(actorId) {
                    updateActorSync(actorId, {
                        testSessionId: null
                    });
                });

                var allTestsPassed = testSession.tests.every(function(t) {
                    return t.result === constants.testResult.PASSED;
                });

                if (allTestsPassed) {
                    testSession.result = constants.testSessionResult.PASSED;
                } else {
                    testSession.result = constants.testSessionResult.FAILED;
                }
            }
        } else {
            ++testSession.currentStepIndex;
        }
    }
}

function reset() {
    db = {        
        actors: {
            // { id: 12345, ip, lastSeenTime, testSessionId, type: 'GMA' }
        },
        testSessions: {
            // { id,  actors: {}, currentTestIndex: 0, result, status,
            // tests: [], timeCreated, timeStarted, timeCompleted }
        },
        testsDefs: {},
        testSuites: {}
    };
}

function updateActorStepSync(sessionId, actorId, testIndex, stepIndex, newData) {
     testSession = db.testSessions[sessionId];

    if (!testSession) {
        throw new Error(util.format('Session ID %s was not found', sessionId));
    }

    var sessionActor = testSession.actors[actorId];
    // Print update requests at the console for troubleshooting
    // console.log("sessionId", sessionId, " actor", sessionActor.type, " testIndex", testIndex, " stepIndex", stepIndex, " newData", newData);

    if (!sessionActor) {
        throw new Error(util.format('Session actor with ID %s was not found for session %s', actorId, sessionId));
    }

    if (newData.status) {
        updateActorStepStatus(sessionActor, testIndex, stepIndex, newData.status);
    }

    if (newData.result) {
        testSession.actors[actorId].tests[testIndex].steps[stepIndex].result = newData.result;
    }

    refreshSession(sessionId);

    function updateActorStepStatus(sessionActor, testIndex, stepIndex, newStatus) {
        var actorTest = sessionActor.tests[testIndex];

        if (!actorTest) {
            actorTest = sessionActor.tests[testIndex] = { currentStepIndex: -1, steps: [] };
            actorTest.group = testSession.tests[testIndex].group;
            actorTest.name = testSession.tests[testIndex].name;
        }

        switch(newStatus) {
            case constants.stepStatus.STARTED:
                // Make sure we're not starting the same step twice
                if (stepIndex === actorTest.currentStepIndex) {
                    throw new Error(util.format('Cannot start step %s because it was already started',
                        stepIndex));
                }
                
                // Make sure the current step is complete
                var currentStep = actorTest.steps[actorTest.currentStepIndex];
                if (currentStep && (currentStep.status !== constants.stepStatus.COMPLETED)) {
                    throw new Error(util.format('Cannot start step %s because the current step is not complete yet',
                        stepIndex));
                }

                // Update session start time
                if (!testSession.timeStarted) {
                    testSession.timeStarted = Date.now();
                }

                // Update current test start time
                var sessionTest = testSession.tests[testIndex];
                if (!sessionTest.timeStarted) {
                    sessionTest.timeStarted = Date.now();
                }

                actorTest.currentStepIndex = stepIndex;

                actorTest.steps[actorTest.currentStepIndex] = {
                    status: constants.stepStatus.STARTED,
                    timeStarted: Date.now(),
                    timeCompleted: null,
                    result: constants.stepResult.PENDING
                }
                break;
            case constants.stepStatus.COMPLETED:
                // Make sure we're completing the current step and not something else
                if (stepIndex !== actorTest.currentStepIndex) {
                    throw new Error(util.format('Cannot complete step %s because it is not the current step (step %s). Actor: %s. Test session: %s. Test index: %s',
                        stepIndex,
                        actorTest.currentStepIndex,
                        actorId,
                        sessionId,
                        testIndex));
                }
                
                // Make sure we're completing the same step twice
                var currentStep = actorTest.steps[stepIndex];
                if (currentStep && (currentStep.status === constants.stepStatus.COMPLETED)) {
                    throw new Error(util.format('Cannot complete step %s because it was already completed. Actor: %s. Test session: %s. Test index: %s',
                        stepIndex,
                        actorId,
                        sessionId,
                        testIndex));
                }
                
                currentStep.status = constants.stepStatus.COMPLETED;
                currentStep.timeCompleted = Date.now();
                break;
            default:
                throw new Error(util.format('Unknown step status "%s". Valid status values are: %s',
                    newStatus,
                    Object.keys(constants.stepStatus)
                        .map((k) => { return '"' + constants.stepStatus[k] + '"'; })
                        .join(', ')));
        }
    }
}

function updateActorSync(actorId, newData) {
    if (db.actors[actorId]) {
        Object.keys(newData).forEach(function(key) {
            db.actors[actorId][key] = newData[key];
        });
    }
}

function updateSessionSync(sessionId, newData) {
    if (db.testSessions[sessionId]) {
        Object.keys(newData).forEach(function(key) {
            db.testSessions[sessionId][key] = newData[key];
        });
    }
}

module.exports = {
    deleteActorSync: deleteActorSync,
    findActorsByTypeSync: findActorsByTypeSync,
    insertActorSync: insertActorSync,
    insertSessionSync: insertSessionSync,
    insertTestDefSync: insertTestDefSync,
    getActorSync: getActorSync,
    getSessionsSync: getSessionsSync,
    getStepStatusSync: getStepStatusSync,
    getSessionSync: getSessionSync,
    getTestSync: getTestSync,
    getTestsSync: getTestsSync,
    reset: reset,
    updateActorSync: updateActorSync,
    updateActorStepSync: updateActorStepSync,
    updateSessionSync: updateSessionSync
};