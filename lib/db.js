var rek = require('rekuire');
var constants = rek('lib/constants');
var helpers = rek('lib/helpers');
var moment = require('moment'); 
var util = require('util');

var db;
reset();

function deleteActorSync(actorId) {
    Object.keys(db.actors).forEach(function(key) {
        if(actorId === db.actors[key].id) {
            delete db.actors[key];
        }
    });
}

function findActorsByTypeSync(actorType) {
    var actors = [];
    if (typeof actorType === 'string') {
        actorType = actorType.trim().toUpperCase();
    }

    Object.keys(db.actors).forEach(function(key) {
        if(!actorType || actorType === db.actors[key].type) {
            actors.push(db.actors[key]);
        }
    });

    return actors;
}

function insertActorSync(actorId, actorType) {
    if (!db.actors[actorId]) {
        db.actors[actorId] =  {
            id: actorId,
            lastSeenTime: Date.now(),
            testSessionId: null,
            type: actorType
        };
    } else {
        throw new Error(util.format('Actor ID %s already exists',
            actorId)); 
    }
}

function insertSessionSync(sessionId) {
    if (!db.testSessions[sessionId]) {
        db.testSessions[sessionId] =  {
            id: sessionId,
            actors: {},
            currentTestIndex: 0,
            currentStepIndex: 0,
            result: constants.testSessionResult.PENDING,
            status: constants.testSessionStatus.ACQUIRING_ACTORS,
            tests: [],
            timeCreated: Date.now(),
            timeStarted: null,
            timeCompleted: null
        };
    } else {
        throw new Error(util.format('Test session %s already exists',
            sessionId));
    }
}

function insertTestDefSync(sessionId, testId) {
    if (!db.tests[testId]) {
        var test = {
            sessionId: sessionId,
            testId: testId,
            timeStarted: null,
            timeCompleted: null,
            currentStepIndex: 0,
            actors: {},
            testData: {},
            steps: {}
        };
        
        db.tests[testId] = test;
    } else {
        throw new Error(util.format('Test %s already exists in session %s',
            testId,
            sessionId));
    }
}

function getActorSync(actorId) {
    return helpers.clone(db.actors[actorId]);
}

function getSessionSync(sessionId) {
    if (db.testSessions[sessionId]) {
        return db.testSessions[sessionId];
    } else {
        return null;
    }
}

function getSessionsSync() {
    var sessions = [];
    var currentSession;

    Object.keys(db.testSessions).forEach(function(sessionId) {
        currentSession = db.testSessions[sessionId];
        sessions.push(currentSession);
    });
    
    return sessions.sort(function(a, b) {
        if (a.timeStarted > b.timeStarted) {
            return 1;
        } else  if (a.timeStarted < b.timeStarted) {
            return -1;
        } else {
            return 0;
        }
    });
}

function getTestSync(sessionId, testName) {
    var testId = getTestId(sessionId, testName);
    var test = db.tests[testId];
    
    if (!test) {
        throw new Error('Test not found');
    }
    
    return test;
}

function getTestId(testGroup, testName) {
    return util.format('%s.%s', testGroup, testName);
}

function getTestsSync() {
    return db.tests;
}

function getStepStatusSync(sessionId, testIndex, stepIndex) {
    var testId = getTestId(sessionId, testName);
    var test = getTestSync(sessionId, testName);
    
    if (test.steps[stepIndex]) {
        return test.steps[stepIndex].status;
    } else {
        throw new Error(util.format('Step %s for test %s was not found',
            stepIndex,
            testId));        
    }
}

// Updates the current test index and current step inxed for a session 
// based on the status reported by actors for the current test step
function refreshSession(sessionId) {
    var testSession = db.testSessions[sessionId];

    // Check if the current step for the current test was completed on all actors
    var currentStepWasCompleted = true;
    var currentStepPassed = true;

    var actorIds = Object.keys(testSession.actors);
    var actor, actorTest, step;

    for (var actorIdIndex = 0; actorIdIndex < actorIds.length; ++actorIdIndex) {
        actor = testSession.actors[actorIds[actorIdIndex]];
        actorTest = actor.tests[testSession.currentTestIndex];

        if (actorTest && actorTest.steps) {
            step = actorTest.steps[testSession.currentStepIndex];

            if (!step) {
                currentStepWasCompleted = false;
                currentStepPassed = false;
                break;
            } else {
                if (step.status !== constants.stepStatus.COMPLETED) {
                    currentStepWasCompleted = false;
                    currentStepPassed = false;
                } else {
                    currentStepPassed = (step.result === constants.stepResult.PASSED);
                }
            }
        } else {
            currentStepWasCompleted = false;
        }
    }

    var currentTestDef = testSession.tests[testSession.currentTestIndex];
    var lastStepDef = currentTestDef.steps[currentTestDef.steps.length - 1];
    var step;

    // Check if the last step for the current test was completed and advance to the next test
    if (currentStepWasCompleted) {
        // The step was completed, so we update it
        step = testSession.tests[testSession.currentTestIndex].steps[testSession.currentStepIndex];
        step.status = constants.testStatus.COMPLETED;
        step.timeCompleted = Date.now();

        // Check whether this was the last step in the test
        if (testSession.currentStepIndex < lastStepDef.index) {
            // Not the last step, so we advance to the next one
            ++testSession.currentStepIndex;
        } else {
            // This is the last step in the test
            testSession.tests[testSession.currentTestIndex].status = constants.testStatus.COMPLETED;

            // Check whether this was the last test in the session
            if (testSession.currentTestIndex < testSession.tests.length - 1) {
                // Not the last test, so we advance to the next one

                ++testSession.currentTestIndex;
                currentTestDef = testSession.tests[testSession.currentTestIndex];

                testSession.currentTestPath = currentTestDef.group;
                testSession.currentTestName = currentTestDef.name;
                testSession.currentStepIndex = 0;
            } else {
                // The test session was completed
                testSession.status = constants.testSessionStatus.COMPLETED;
            }
        }
    }
}

function reset() {
    db = {        
        actors: {
            // { id: 12345, ip, lastSeenTime, testSessionId, type: 'GMA' }
        },
        testSessions: {
            // { id,  actors: {}, currentTestIndex: 0, result, status,
            // tests: [], timeCreated, timeStarted, timeCompleted }
        },
        testsDefs: {},
        testSuites: {}
    };
}

function updateActorStepSync(sessionId, actorId, testIndex, stepIndex, newData) {
   var testSession = db.testSessions[sessionId];

   if (!testSession) {
       throw new Error(util.format('Session ID %s was not found', sessionId));
   }

   var sessionActor = testSession.actors[actorId];

   if (!sessionActor) {
       throw new Error(util.format('Session actor with ID %s was not found for session %s', actorId, sessionId));
   }

    if (newData.status) {
        updateStepStatus(sessionActor, testIndex, stepIndex, newData.status);
    }

    if (newData.result) {
        testSession.actors[actorId].tests[testIndex].steps[stepIndex].result = newData.result;
    }

    refreshSession(sessionId);

   function updateStepStatus(sessionActor, testIndex, stepIndex, newStatus) {
        var actorTest = sessionActor.tests[testIndex];

        if (!actorTest) {
            actorTest = sessionActor.tests[testIndex] = { currentStepIndex: -1, steps: [] };
            actorTest.group = testSession.tests[testIndex].group;
            actorTest.name = testSession.tests[testIndex].name;
        }

        switch(newStatus) {
            case constants.stepStatus.STARTED:
                // Make sure we're not starting the same step twice
                if (stepIndex === actorTest.currentStepIndex) {
                    throw new Error(util.format('Cannot start step %s because it was already started',
                        stepIndex));
                }
                
                // Make sure the current step is complete
                var currentStep = actorTest.steps[actorTest.currentStepIndex];
                if (currentStep && (currentStep.status !== constants.stepStatus.COMPLETED)) {
                    throw new Error(util.format('Cannot start step %s because the current step is not complete yet',
                        stepIndex));
                }

                actorTest.currentStepIndex = stepIndex;

                actorTest.steps[actorTest.currentStepIndex] = {
                    status: constants.stepStatus.STARTED,
                    timeStarted: Date.now(),
                    timeCompleted: null,
                    result: constants.stepResult.PENDING
                }
                break;
            case constants.stepStatus.COMPLETED:
                // Make sure we're completing the current step and not something else
                if (stepIndex !== actorTest.currentStepIndex) {
                    throw new Error(util.format('Cannot complete step %s because it is not the current step (step %s). Actor: %s. Test session: %s. Test index: %s',
                        stepIndex,
                        actorTest.currentStepIndex,
                        actorId,
                        sessionId,
                        testIndex));
                }
                
                // Make sure we're completing the same step twice
                var currentStep = actorTest.steps[stepIndex];
                if (currentStep && (currentStep.status === constants.stepStatus.COMPLETED)) {
                    throw new Error(util.format('Cannot complete step %s because it was already completed. Actor: %s. Test session: %s. Test index: %s',
                        stepIndex,
                        actorId,
                        sessionId,
                        testIndex));
                }
                
                currentStep.status = constants.stepStatus.COMPLETED;
                currentStep.timeCompleted = Date.now();
                break;
            default:
                throw new Error(util.format('Unknown step status "%s". Valid status values are: %s',
                    newStatus,
                    Object.keys(constants.stepStatus)
                        .map((k) => { return '"' + constants.stepStatus[k] + '"'; })
                        .join(', ')));
        }
    }
}

function updateActorSync(actorId, newData) {
    if (db.actors[actorId]) {
        Object.keys(newData).forEach(function(key) {
            db.actors[actorId][key] = newData[key];
        });
    }
}

function updateSessionSync(sessionId, newData) {
    if (db.testSessions[sessionId]) {
        Object.keys(newData).forEach(function(key) {
            db.testSessions[sessionId][key] = newData[key];
        });
    }
}

function updateStepSync(sessionId, testId, stepIndex, newData) {
    var test = getTestSync(sessionId, testId);
    
    // Update status
    var newStatus = newData.status;
    if (newStatus && typeof newStatus === 'string') {
        updateStepStatus(test, stepIndex, newStatus);
    }

    // Update result
    var newResult = newData.result;
    if (newResult && typeof newResult === 'string') {
        updateResult(test, stepIndex, newResult);
    }
    
    function updateStepStatus(sessionId, testId, stepIndex, actorId, newStatus) {
        var testSession = db.testSessions[sessionId];

        if (!testSession) {
            throw new Error(util.format('Session ID %s was not found', sessionId));
        }

        var test = testSession.tests[testId];

        if (!test) {
            throw new Error(util.format('Test ID %s was not found within session %s', testId, sessionId));
        }

        switch(newStatus) {
            case constants.stepStatus.STARTED:
                // Make sure we're not starting the same step twice
                if (stepIndex === test.actors[actorId].currentStepIndex) {
                    throw new Error(util.format('Cannot start step %s because it was already started',
                        stepIndex));
                }
                
                // Make sure the current step is complete
                var currentStep = test.steps[test.currentStepIndex];
                if (currentStep && (currentStep.status !== constants.stepStatus.COMPLETED)) {
                    throw new Error(util.format('Cannot start step %s because the current step is not complete yet',
                        stepIndex));
                }
                
                // Make sure the new step index follows right after the last completed step index
                if (stepIndex !== test.currentStepIndex + 1) {
                    throw new Error(util.format('Cannot start step %s because the last completed step was %s',
                        stepIndex,
                        test.currentStepIndex));
                }
                
                test.currentStepIndex = test.currentStepIndex + 1;
                test.steps[test.currentStepIndex] = {
                    status: constants.stepStatus.STARTED,
                    timeStarted: Date.now(),
                    timeCompleted: null,
                    result: constants.stepResult.PENDING
                }
                break;
            case constants.stepStatus.COMPLETED:
                // Make sure we're completing the current step and not something else
                if (stepIndex !== test.currentStepIndex) {
                    throw new Error(util.format('Cannot complete step %s because it is not the current step (step %s)',
                        stepIndex,
                        test.currentStepIndex));
                }
                
                // Make sure we're completing the same step twice
                var currentStep = test.steps[stepIndex];
                if (currentStep && (currentStep.status === constants.stepStatus.COMPLETED)) {
                    throw new Error(util.format('Cannot complete step %s because it was already completed',
                        stepIndex));
                }
                
                currentStep.status = constants.stepStatus.COMPLETED;
                currentStep.timeCompleted = Date.now();
                break;
            default:
                throw new Error(util.format('Unknown step status "%s". Valid status values are: %s',
                    newStatus,
                    Object.keys(constants.stepStatus)
                        .map((k) => { return '"' + constants.stepStatus[k] + '"'; })
                        .join(', ')));
        }
    }

    function updateResult(test, stepIndex, newResult) {
        newResult = newResult.trim().toLowerCase();

        var validResult = false;
        Object.keys(constants.testResult).forEach(function(key) {
            if (constants.testResult[key] === newResult) {
                validResult = true;
            }
        });

        if (!validResult) {
            throw new Error(util.format('Unknown step result "%s". Valid result values are: %s',
                    newResult,
                    Object.keys(constants.testResult)
                        .map((k) => { return '"' + constants.testResult[k] + '"'; })
                        .join(', ')));
        }

        test.steps[stepIndex].result = newResult;
    }
}

module.exports = {
    deleteActorSync: deleteActorSync,
    findActorsByTypeSync: findActorsByTypeSync,
    insertActorSync: insertActorSync,
    insertSessionSync: insertSessionSync,
    insertTestDefSync: insertTestDefSync,
    getActorSync: getActorSync,
    getSessionsSync: getSessionsSync,
    getStepStatusSync: getStepStatusSync,
    getSessionSync: getSessionSync,
    getTestSync: getTestSync,
    getTestsSync: getTestsSync,
    reset: reset,
    updateActorSync: updateActorSync,
    updateActorStepSync: updateActorStepSync,
    updateSessionSync: updateSessionSync,
    updateStepSync: updateStepSync
};