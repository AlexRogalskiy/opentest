var fs = require('fs');
var moment = require('moment'); 
var path = require('path');

require('moment-timezone');

function clone(obj) {
    var copy;

    // Handle the 3 simple types, and null or undefined
    if (null == obj || 'object' != typeof obj) return obj;

    // Handle Date
    if (obj instanceof Date) {
        copy = new Date();
        copy.setTime(obj.getTime());
        return copy;
    }

    // Handle Array
    if (obj instanceof Array) {
        copy = [];
        for (var i = 0, len = obj.length; i < len; i++) {
            copy[i] = clone(obj[i]);
        }
        return copy;
    }

    // Handle Object
    if (obj instanceof Object) {
        copy = {};
        for (var attr in obj) {
            if (obj.hasOwnProperty(attr)) copy[attr] = clone(obj[attr]);
        }
        return copy;
    }

    throw new Error('Unable to copy object. The object type is not supported.');
}

function deleteDirRecursive(path) {
	try {
		if (fs.existsSync(path)) {
			fs.readdirSync(path).forEach(function (file, index) {
				var fullPath = path + "/" + file;
				if (fs.lstatSync(fullPath).isDirectory()) {
					deleteFolderRecursive(fullPath);
				} else {
					fs.unlinkSync(fullPath);
				}
			});
			fs.rmdirSync(path);
		}
	} catch (err) {
		// Swallowing the exception is fine here
	}
}

function directoryExists(dirPath) {
	try {
		return fs.statSync(dirPath).isDirectory();
	} catch (err) {
		return false;
	}
}

function endsWith(testString, searchString, position) {
	var subjectString = testString.toString();
	if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {
		position = subjectString.length;
	}
	
	position -= searchString.length;
	var lastIndex = subjectString.indexOf(searchString, position);
	return lastIndex !== -1 && lastIndex === position;
}

function fileExists(filePath) {
	try {
		return fs.statSync(filePath).isFile();
	} catch (err) {
		return false;
	}
}

// Utility function for string formatting
// example: format("{0}, {1}!", "Hello", "world") // "Hello, world!"
function format(text) {
	var args = arguments;
	return text.replace(
		/\{(\d+)\}/g,
		function (match, index) {
			var argIndex = Number(index) + 1;
			return typeof args[argIndex] !== 'undefined' ?
				args[argIndex] : match;
		});
}

// Looks into an object for properties that represent time values and inserts
// additional properties that represent the coresponding local time
function insertLocalTimes(obj, timezone, propertyNames) {
	if (!propertyNames) {
		Object.keys(obj).forEach(function(key) {
			if((startsWith(key, 'time') || endsWith(key, 'Time')) && typeof obj[key] === 'number' && obj[key] > 21600000) {
				insertLocalTime(obj, timezone, key);
			}
		});
	} else {
		propertyNames.forEach(function(propertyName) {
			insertLocalTime(obj, timezone, propertyName);
		});
	}

	function insertLocalTime(obj, timezone, propertyName) {
		obj[propertyName + 'Local'] = moment.tz(obj[propertyName], timezone).valueOf();
	}
}

function isValidUrl(str) {
	var urlRegexp = new RegExp(
		"^" +
		// protocol identifier
		"(?:(?:https?|ftp)://)" +
		// user:pass authentication
		"(?:\\S+(?::\\S*)?@)?" +
		"(?:" +
		// IP address exclusion
		// private & local networks
		"(?!(?:10|127)(?:\\.\\d{1,3}){3})" +
		"(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})" +
		"(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})" +
		// IP address dotted notation octets
		// excludes loopback network 0.0.0.0
		// excludes reserved space >= 224.0.0.0
		// excludes network & broacast addresses
		// (first & last IP address of each class)
		"(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])" +
		"(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}" +
		"(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))" +
		"|" +
		// host name
		"(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)" +
		// domain name
		"(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*" +
		// TLD identifier
		"(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))" +
		// TLD may end with dot
		"\\.?" +
		")" +
		// port number
		"(?::\\d{2,5})?" +
		// resource path
		"(?:[/?#]\\S*)?" +
		"$", "i");
	
	return urlRegexp.test(str);
}

// Pad a number (or string) up to a given width
// with zeroes, or any other character
function pad(n, width, z) {
  z = z || '0';
  n = n + '';
  return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;
}

function parseBool(value) {
	value = value.toString().trim().toUpperCase();
	var result;
	
	switch (value) {
		case 'TRUE': result = true; break;
		case 'FALSE': result = false; break;
		case '1': result = true; break;
		case '0': result = false; break;
		case 'YES': result = true; break;
		case 'NO': result = false; break;
		default: throw new Error('Failed to convert value "' + value + '" to a boolean.');
	}
	
	return result;
}

function startsWith(testString, searchString, position){
	position = position || 0;
	return testString.substr(position, searchString.length) === searchString;
}

function writeFile(filePath, fileName, data) {
	if (typeof data !== 'string') {
		data = JSON.stringify(data, null, '\t');
	}
	
	fs.writeFileSync(path.join(filePath, fileName), data); 
}

module.exports = {
	clone: clone,
	deleteDirRecursive: deleteDirRecursive,
	directoryExists: directoryExists,
	endsWith: endsWith,
	fileExists: fileExists,
	format: format,
	insertLocalTimes: insertLocalTimes,
	isValidUrl: isValidUrl,
	pad: pad,
	parseBool: parseBool,
	startsWith: startsWith,
	writeFile: writeFile
};