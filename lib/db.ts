import * as constants from './constants';
var helpers = require('./helpers');
var moment = require('moment');
var util = require('util');

/** Stores all the relevant information about a test session, including its actors,
 * current test and current step, timestamps, status, etc.  */
export interface ITestSessionInfo {
    id: string,
    actors: {},
    currentTestIndex: number,
    currentStepIndex: number,
    result: string,
    status: string,
    tests: ITestInfo[],
    timeCreated: number,
    timeStarted: number,
    timeCompleted: number
}

export interface ITestStepInfo {

}

export interface ITestInfo {
    name: string;
    path: string;
    sharedData: Object;
}

/** In-memory database that stores transient data */
export interface IMemoryDb {
    actors: {},
    testSessions: {},
    tests: {}
}

/** Object that stores the in-memory DB */
var dbObj: IMemoryDb;

resetDb();

export function deleteActorSync(actorId) {
    Object.keys(dbObj.actors).forEach(function (key) {
        if (actorId === dbObj.actors[key].id) {
            delete dbObj.actors[key];
        }
    });
}

export function findActorsByTypeSync(actorType?: string) {
    var actors = [];
    if (typeof actorType === 'string') {
        actorType = actorType.trim().toUpperCase();
    }

    Object.keys(dbObj.actors).forEach(function (key) {
        if (!actorType || actorType === dbObj.actors[key].type) {
            actors.push(dbObj.actors[key]);
        }
    });

    return actors;
}

export function insertActorSync(actorId, actorType) {
    if (!dbObj.actors[actorId]) {
        dbObj.actors[actorId] = {
            id: actorId,
            lastSeenTime: Date.now(),
            testSessionId: null,
            type: actorType
        };
    } else {
        throw new Error(util.format('Actor ID %s already exists',
            actorId));
    }
}

export function insertSessionSync(sessionId) {
    if (!dbObj.testSessions[sessionId]) {
        dbObj.testSessions[sessionId] = {
            id: sessionId,
            actors: {},
            currentTestIndex: 0,
            currentStepIndex: 0,
            result: constants.testSessionResult.PENDING,
            status: constants.testSessionStatus.ACQUIRING_ACTORS,
            tests: [],
            timeCreated: Date.now(),
            timeStarted: null,
            timeCompleted: null
        } as ITestSessionInfo;
    } else {
        throw new Error(util.format('Test session %s already exists',
            sessionId));
    }
}

export function getActorSync(actorId) {
    return helpers.clone(dbObj.actors[actorId]);
}

export function getSessionSync(sessionId): ITestSessionInfo {
    if (dbObj.testSessions[sessionId]) {
        return dbObj.testSessions[sessionId];
    } else {
        return null;
    }
}

export function getSessionsSync() {
    var sessions = [];
    var currentSession;

    Object.keys(dbObj.testSessions).forEach(function (sessionId) {
        currentSession = dbObj.testSessions[sessionId];
        sessions.push(currentSession);
    });

    return sessions.sort(function (a, b) {
        if (a.timeStarted > b.timeStarted) {
            return 1;
        } else if (a.timeStarted < b.timeStarted) {
            return -1;
        } else {
            return 0;
        }
    });
}

function getTestId(testGroup, testName) {
    return util.format('%s.%s', testGroup, testName);
}

export function getTestsSync() {
    var actorIds = Object.keys(dbObj.actors);
    var actor;

    for (var actorIdIndex = 0; actorIdIndex < actorIds.length; ++actorIdIndex) {
        actor = dbObj.actors[actorIds[actorIdIndex]];

        // TODO: Compute the union of all tests from all actors
        if (actor.catalog && actor.catalog.tests) {
            return actor.catalog.tests;
        }
    }

    return null;
}

// Updates the current test index and current step inxed for a session 
// based on the status reported by actors for the current test step
function refreshSession(sessionId) {
    var testSession = dbObj.testSessions[sessionId];

    // Check if the current step for the current test was completed on all actors
    var currentStepWasCompleted = true;
    var currentStepPassed = true;

    var actorIds = Object.keys(testSession.actors);
    var actor, actorTest, step;

    for (var actorIdIndex = 0; actorIdIndex < actorIds.length; ++actorIdIndex) {
        actor = testSession.actors[actorIds[actorIdIndex]];
        actorTest = actor.tests[testSession.currentTestIndex];

        if (actorTest && actorTest.steps) {
            step = actorTest.steps[testSession.currentStepIndex];

            if (!step) {
                currentStepWasCompleted = false;
                currentStepPassed = false;
                break;
            } else {
                if (step.status !== constants.stepStatus.COMPLETED) {
                    currentStepWasCompleted = false;
                    currentStepPassed = false;
                } else {
                    if (step.result !== constants.stepResult.PASSED) {
                        currentStepPassed = false;
                    }
                }
            }
        } else {
            currentStepWasCompleted = false;
        }
    }

    var currentTestDef = testSession.tests[testSession.currentTestIndex];
    var lastStepIndex = Math.max.apply(null, currentTestDef.steps.map(function (s) {
        return s.index;
    }));

    // Check if the last step for the current test was completed and advance to the next test
    if (currentStepWasCompleted) {
        var currentTest = testSession.tests[testSession.currentTestIndex];
        var currentStep = currentTest.steps[testSession.currentStepIndex];

        currentStep.status = constants.stepStatus.COMPLETED;
        currentStep.result = currentStepPassed ? constants.stepResult.PASSED : constants.stepResult.FAILED;
        currentStep.timeCompleted = Date.now();

        var reachedLastStep = (testSession.currentStepIndex >= lastStepIndex);
        var reachedLastTest = testSession.currentTestIndex >= testSession.tests.length - 1;

        if (reachedLastStep || !currentStepPassed) {
            currentTest.status = constants.testStatus.COMPLETED;
            currentTest.result = currentStepPassed ? constants.testResult.PASSED : constants.testResult.FAILED;
            currentTest.timeCompleted = Date.now();

            if (!reachedLastTest) {
                ++testSession.currentTestIndex;
                testSession.currentStepIndex = 0;
            } else {
                testSession.status = constants.testSessionStatus.COMPLETED;
                testSession.timeCompleted = Date.now();

                // Reset actors
                var actorIds = Object.keys(testSession.actors);
                actorIds.forEach(function (actorId) {
                    updateActorSync(actorId, {
                        testSessionId: null
                    });
                });

                var allTestsPassed = testSession.tests.every(function (t) {
                    return t.result === constants.testResult.PASSED;
                });

                if (allTestsPassed) {
                    testSession.result = constants.testSessionResult.PASSED;
                } else {
                    testSession.result = constants.testSessionResult.FAILED;
                }
            }
        } else {
            ++testSession.currentStepIndex;
        }
    }
}

export function resetDb() {
    dbObj = {
        actors: {
            // { id: 12345, ip, lastSeenTime, testSessionId, type: 'GMA', catalog, tags }
        },
        testSessions: {
            // { id,  actors: {}, currentTestIndex: 0, result, status,
            // tests: [], timeCreated, timeStarted, timeCompleted }
        },
        tests: {}
    };
}

export function updateActorStepSync(sessionId, actorId, testIndex, stepIndex, newData) {
    var testSession = dbObj.testSessions[sessionId];

    if (!testSession) {
        throw new Error(util.format('Session ID %s was not found', sessionId));
    }

    var sessionActor = testSession.actors[actorId];
    // Print update requests at the console for troubleshooting
    // console.log("sessionId", sessionId, " actor", sessionActor.type, " testIndex", testIndex, " stepIndex", stepIndex, " newData", newData);

    if (!sessionActor) {
        throw new Error(util.format('Session actor with ID %s was not found for session %s', actorId, sessionId));
    }

    if (newData.status) {
        updateActorStepStatus(sessionActor, testIndex, stepIndex, newData.status);
    }

    if (newData.result) {
        testSession.actors[actorId].tests[testIndex].steps[stepIndex].result = newData.result;
    }

    if (newData.details) {
        testSession.actors[actorId].tests[testIndex].steps[stepIndex].details = newData.details;
    }

    refreshSession(sessionId);

    function updateActorStepStatus(sessionActor, testIndex, stepIndex, newStatus) {
        var actorTest = sessionActor.tests[testIndex];

        if (!actorTest) {
            actorTest = sessionActor.tests[testIndex] = { currentStepIndex: -1, steps: [] };
            actorTest.group = testSession.tests[testIndex].group;
            actorTest.name = testSession.tests[testIndex].name;
        }

        var currentStep = actorTest.steps[actorTest.currentStepIndex];

        switch (newStatus) {
            case constants.stepStatus.STARTED:
                // Make sure we're not starting the same step twice
                if (stepIndex === actorTest.currentStepIndex) {
                    throw new Error(util.format('Cannot start step %s because it was already started',
                        stepIndex));
                }

                // Make sure the current step is complete
                if (currentStep && (currentStep.status !== constants.stepStatus.COMPLETED)) {
                    throw new Error(util.format('Cannot start step %s because the current step is not complete yet',
                        stepIndex));
                }

                // Update session start time
                if (!testSession.timeStarted) {
                    testSession.timeStarted = Date.now();
                }

                // Update current test start time
                var sessionTest = testSession.tests[testIndex];
                if (!sessionTest.timeStarted) {
                    sessionTest.timeStarted = Date.now();
                }

                actorTest.currentStepIndex = stepIndex;

                actorTest.steps[actorTest.currentStepIndex] = {
                    status: constants.stepStatus.STARTED,
                    timeStarted: Date.now(),
                    timeCompleted: null,
                    result: constants.stepResult.PENDING
                }
                break;
            case constants.stepStatus.COMPLETED:
                // Make sure we're completing the current step and not something else
                if (stepIndex !== actorTest.currentStepIndex) {
                    throw new Error(util.format('Cannot complete step %s because it is not the current step (step %s). Actor: %s. Test session: %s. Test index: %s',
                        stepIndex,
                        actorTest.currentStepIndex,
                        actorId,
                        sessionId,
                        testIndex));
                }

                currentStep.status = constants.stepStatus.COMPLETED;
                currentStep.timeCompleted = Date.now();
                break;
            default:
                throw new Error(util.format('Unknown step status "%s". Valid status values are: %s',
                    newStatus,
                    Object.keys(constants.stepStatus)
                        .map((k) => { return '"' + constants.stepStatus[k] + '"'; })
                        .join(', ')));
        }
    }
}

export function updateActorSync(actorId, newData) {
    if (dbObj.actors[actorId]) {
        Object.keys(newData).forEach(function (key) {
            dbObj.actors[actorId][key] = newData[key];
        });
    }
}

export function updateSessionSync(sessionId, newData) {
    if (dbObj.testSessions[sessionId]) {
        Object.keys(newData).forEach(function (key) {
            dbObj.testSessions[sessionId][key] = newData[key];
        });
    }
}