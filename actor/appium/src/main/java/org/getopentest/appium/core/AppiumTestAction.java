package org.getopentest.appium.core;

import io.appium.java_client.AppiumDriver;
import io.appium.java_client.MobileDriver;
import io.appium.java_client.MobileElement;
import io.appium.java_client.TouchAction;
import io.appium.java_client.android.AndroidDriver;
import io.appium.java_client.ios.IOSDriver;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Observable;
import java.util.Observer;
import java.util.concurrent.TimeUnit;
import org.apache.commons.io.FileUtils;
import org.getopentest.appium.core.Condition;
import org.getopentest.base.TestAction;
import org.getopentest.base.TestActorEvents;
import org.getopentest.contracts.ITestActor;
import org.getopentest.logging.Logger;
import org.getopentest.util.Config;
import org.openqa.selenium.By;
import org.openqa.selenium.Dimension;
import org.openqa.selenium.OutputType;
import org.openqa.selenium.Point;
import org.openqa.selenium.TakesScreenshot;
import org.openqa.selenium.support.ui.ExpectedConditions;
import org.openqa.selenium.support.ui.WebDriverWait;

public abstract class AppiumTestAction extends TestAction {

    protected static Config config;

    protected AppiumDriver<MobileElement> driver;

    private static boolean initialized;

    public AppiumTestAction() {
        AppiumTestAction.config = AppiumHelper.getConfig();

        this.driver = AppiumHelper.getDriver();
        if (this.driver == null) {
            throw new RuntimeException("The Appium driver was not initialized. You must run the InitAppium action to do the initialization before using any of mobile-related test actions.");
        }

        int implicitWaitSec = this.config.getInteger("appium.implicitWaitSec", 0);
        this.driver.manage().timeouts().implicitlyWait(implicitWaitSec, TimeUnit.SECONDS);
    }

    private String getCurrentTime() {
        Calendar cal = Calendar.getInstance();
        SimpleDateFormat sdf = new SimpleDateFormat("HHmmss");
        return sdf.format(cal.getTime());
    }

    /**
     * Locates and returns a UI element
     *
     * @param locator Identifies the element to look for
     */
    protected MobileElement getElement(By locator) {
        return getElement(locator, AppiumHelper.getExplicitWaitSec());
    }

    /**
     * Locates and returns a UI element
     *
     * @param locator Identifies the element to look for
     * @param timeoutSec Maximum time to wait for the element to become
     * available
     * @return The UI element that was requested
     */
    protected MobileElement getElement(By locator, int timeoutSec) {
        WebDriverWait wait = new WebDriverWait(driver, timeoutSec);
        wait.until(ExpectedConditions.presenceOfElementLocated(locator));
        return this.driver.findElement(locator);
    }

    @Override
    public void initialize() {
        super.initialize();

        // We run this code in the "initialize" method and not in the constructor, 
        // because at the time the constructor is run, the "actor" field of the 
        // test action is not yet populated.
        if (!AppiumTestAction.initialized) {
            AppiumTestAction.initialized = true;

            this.getActor().addObserver(new Observer() {
                @Override
                public void update(Observable eventSource, Object eventData) {
                    if (eventSource instanceof ITestActor) {
                        if (eventData == TestActorEvents.TEST_COMPLETED) {
                            if (!AppiumHelper.getConfig().getBoolean("appium.reuseDriver", false)) {
                                AppiumHelper.discardDriver();
                            }
                        }
                    }
                }
            });
        }
    }

    protected void hideKeyboard() {
        this.hideKeyboard(null);
    }

    protected void hideKeyboard(String keyName) {
        try {
            if (driver instanceof IOSDriver) {
                IOSDriver iosDriver = (IOSDriver) driver;
                if (keyName != null) {
                    iosDriver.hideKeyboard(keyName);
                } else {
                    iosDriver.hideKeyboard();
                }
            } else if (driver instanceof AndroidDriver) {
                AndroidDriver androidDriver = (AndroidDriver) driver;
                androidDriver.hideKeyboard();
            }
        } catch(Exception ex) {
            // We don't want to throw this exception, because it's cause might
            // be that the keyboard was not on the screen to start with
            Logger.warning("There was an error while attempting to hide the keyboard", ex);
        }
    }

    public By readLocatorArgument(String argName, By defaultValue) {
        if (this.hasArgument(argName)) {
            return readLocatorArgument(argName);
        } else {
            return defaultValue;
        }
    }

    protected By readLocatorArgument(String argName) {
        Object argumentValue = readArgument(argName);

        if (argumentValue instanceof String) {
            Map<String, Object> newArgValue = new HashMap<String, Object>();
            newArgValue.put("xpath", argumentValue);
            argumentValue = newArgValue;
        }

        Map<String, Object> argValueAsMap = (Map<String, Object>) argumentValue;

        if (argValueAsMap.containsKey("xpath")) {
            if (argValueAsMap.get("xpath").toString().contains("''")) {
                return By.xpath(argValueAsMap.get("xpath").toString().replace("''", "'"));
            } else {
                return By.xpath(argValueAsMap.get("xpath").toString());
            }
        } else if (argValueAsMap.containsKey("id")) {
            return By.id(argValueAsMap.get("id").toString());

        } else if (argValueAsMap.containsKey("name")) {
            return By.name(argValueAsMap.get("name").toString());

        } else {
            throw new RuntimeException("Provide at least 1 identifier for the object by populating at least 1 of the following properties: xpath, id, name.");
        }

    }

    //TODO: This method must be removed after refactoring the code that uses it
    protected By readLocatorArgumentUpdateWithEnabled(String argName) {
        Object argumentValue = readArgument(argName);

        if (argumentValue instanceof String) {
            Map<String, Object> newArgValue = new HashMap<String, Object>();
            newArgValue.put("xpath", argumentValue);
            argumentValue = newArgValue;
        }

        Map<String, Object> argValueAsMap = (Map<String, Object>) argumentValue;

        if (argValueAsMap.containsKey("xpath")) {
            if (argValueAsMap.get("xpath").toString().contains("''")) {
                return By.xpath(argValueAsMap.get("xpath").toString().replace("''", "'") + "[@enabled='true']");
            } else {
                return By.xpath(argValueAsMap.get("xpath").toString() + "[@enabled='true']");
            }
        } else if (argValueAsMap.containsKey("id")) {
            return By.xpath(argValueAsMap.get("id").toString());
        } else if (argValueAsMap.containsKey("name")) {
            return By.xpath(argValueAsMap.get("name").toString());
        } else {
            throw new RuntimeException("Provide at least 1 identifier for the object by populating at least 1 of the following properties: xpath, id, name.");
        }
    }

    @Override
    public void run() {
        super.run();
    }

    protected void swipeAndCheckElementVisible(By locator, String direction) {
        Logger.trace(String.format("AppiumTestAction.swipeAndCheckElementVisible (%s, %s)",
                locator,
                direction));

        if (direction.equalsIgnoreCase("none")) {
            WebDriverWait wait = new WebDriverWait(driver, AppiumHelper.getExplicitWaitSec());
            wait.until(ExpectedConditions.visibilityOfElementLocated(locator));
        } else {
            // TODO: Revisit this and implement a smarter algorithm - not ok to repeat this for an arbitrary number of times
            int maxSwipeCount = Integer.valueOf(AppiumTestAction.config.getString("appium.maxSwipeCount", "50"));

            for (int i = 0; i < maxSwipeCount; i++) {
                try {
                    Logger.trace(String.format("AppiumTestAction.swipeAndCheckElementVisible iteration %s", i + 1));
                    waitForElementVisible(locator, 1);
                    return;
                } catch (Exception ex) {
                    swipe(direction);
                }
            }

            throw new RuntimeException(String.format("Element was not visible: %s", locator.toString()));
        }
    }

    protected void swipeAndCheckElementNotVisible(By locator, String direction) {
        Logger.trace(String.format("AppiumTestAction.swipeAndCheckElementNotVisible (%s, %s)",
                locator,
                direction));

        if (direction.equalsIgnoreCase("none")) {
            WebDriverWait wait = new WebDriverWait(driver, AppiumHelper.getExplicitWaitSec());
            wait.until(ExpectedConditions.invisibilityOfElementLocated(locator));
        } else {
            // TODO: Revisit this and implement a smarter algorithm - not ok to repeat this for an arbitrary number of times
            int maxSwipeCount = Integer.valueOf(AppiumTestAction.config.getString("appium.maxSwipeCount", "50"));

            for (int i = 0; i < maxSwipeCount; i++) {
                try {
                    Logger.trace(String.format("AppiumTestAction.swipeAndCheckElementVisible iteration %s", i + 1));
                    waitForElementVisible(locator, 1);
                    throw new RuntimeException(String.format("Element was found to be visible: %s", locator.toString()));
                } catch (Exception ex) {
                    swipe(direction);
                }
            }
        }
    }

    protected void swipe(int fromX, int fromY, int toX, int toY) {
        Logger.trace(String.format("AppiumTestAction.swipe (%s, %s, %s, %s)",
                fromX, fromY, toX, toY));

        driver.swipe(fromX, fromY, toX, toY, 1000);
    }

    protected void swipe(String swipeDirection) {
        Logger.trace(String.format("AppiumTestAction.swipe(%s)", swipeDirection));

        Dimension screenSize;
        screenSize = driver.manage().window().getSize();

        int startX, endX, startY, endY;

        startX = endX = screenSize.width / 2;
        startY = endY = screenSize.height / 2;

        if (swipeDirection.equalsIgnoreCase("down")) {
            startY = (int) (screenSize.height * 0.80);
            endY = (int) (screenSize.height * 0.20);
        } else if (swipeDirection.equalsIgnoreCase("up")) {
            startY = (int) (screenSize.height * 0.20);
            endY = (int) (screenSize.height * 0.80);
        } else if (swipeDirection.equalsIgnoreCase("left")) {
            startX = (int) (screenSize.width * 0.90);
            endX = (int) (screenSize.width * 0.10);
        } else if (swipeDirection.equalsIgnoreCase("right")) {
            startX = (int) (screenSize.width * 0.10);
            endX = (int) (screenSize.width * 0.90);
        }

        swipe(startX, startY, endX, endY);
    }

    protected void swipeUp(MobileElement element) {
        Point point = element.getLocation();
        Dimension size = driver.manage().window().getSize();
        if (AppiumHelper.isPlatform("android")) {
            int screenHeight = (int) (size.height * 0.10);
            int elementY = point.getY();

            int endX = 0;
            int endY = ((int) screenHeight - (elementY + element.getSize().height));

            TouchAction action = new TouchAction((MobileDriver) driver);
//              Logger.debug("Device height:"+size.getHeight()+"$$$ Device width:"+size.getWidth());
//              Logger.debug("Element X:"+point.getX()+"$$$ Element Y:"+point.getY());
//              Logger.debug("Element Height:"+element.getSize().height+"$$$$ Element Width:"+element.getSize().width);
//              Logger.debug("end X:"+endX+"$$$$end Y:"+endY);
            //action.press(element).moveTo(endX, endY).release().perform();
            action.press(element.getCenter().getX(), element.getCenter().getY()).moveTo(endX, screenHeight - element.getCenter().getY()).release().perform();

        } else {
            int endx = (int) (size.width * 0.8);
            int startx = (int) (size.width * 0.2);
            int endy = (int) (size.height / 1.5);
            int starty = (int) (size.height / 8);

            TouchAction action = new TouchAction((MobileDriver) driver);
            action.press(startx, endy).moveTo(-startx, -endy).release().perform();
        }
    }

    protected void swipeDown(MobileElement element) {
        Point point = element.getLocation();
        Dimension size = driver.manage().window().getSize();

        int screenHeight = (int) (size.height * 0.90);
        int elementY = point.getY();

        int endX = 0;
        int endY = ((int) screenHeight - elementY);
//        Logger.debug("Device height:" + size.getHeight() + "$$$ Device width:" + size.getWidth());
//        Logger.debug("Element X:" + point.getX() + "$$$ Element Y:" + point.getY());
//        Logger.debug("Element Height:" + element.getSize().height + "$$$$ Element Width:" + element.getSize().width);
//        Logger.debug("end X:" + endX + "$$$$end Y:" + endY);
        TouchAction action = new TouchAction((MobileDriver) driver);
        //action.press(element).moveTo(endX, endY).release().perform();
        action.press(element.getCenter().getX(), element.getCenter().getY()).moveTo(endX, screenHeight - element.getCenter().getY()).release().perform();

    }

    protected void swipeLeft(MobileElement element) {
        Point point = element.getLocation();
        Point p = element.getCenter();
        Dimension size = driver.manage().window().getSize();
        if (AppiumHelper.isPlatform("android")) {
            int screenWidth = (int) (size.width * 0.10);
            // int elementX = point.getX();
            int elementX = p.getX();

            int endY = 0;
            int endX = 0 - (element.getSize().getWidth());

            //        Logger.debug("Device height:" + size.getHeight() + "$$$ Device width:" + size.getWidth());
            //        Logger.debug("Element X:" + point.getX() + "$$$ Element Y:" + point.getY());
            //        Logger.debug("Element Height:" + element.getSize().height + "$$$$ Element Width:" + element.getSize().width);
            //        Logger.debug("end X:" + endX + "$$$$end Y:" + endY);
            TouchAction action = new TouchAction((MobileDriver) driver);
            //action.press(element).moveTo(endX, endY).release().perform();
            action.press((int) (point.getX() + (element.getSize().getWidth() * 0.90)), element.getCenter().getY()).moveTo((int) (screenWidth - (point.getX() + (element.getSize().getWidth() * 0.90))), endY).release().perform();

        } else {
            int endY = 0;
            int startX = (int) (size.width - 10);
            int startY = (int) (size.height / 1.8);

            TouchAction action = new TouchAction((MobileDriver) driver);
            action.press(startX, startY).moveTo(-startX, endY).release().perform();
        }
    }

    protected void swipeRight(MobileElement element) {
        Point point = element.getLocation();
        Point p = element.getCenter();

        Dimension size = driver.manage().window().getSize();

        int screenWidth = (int) (size.width * 0.90);
        // int elementX = point.getX();
        int elementX = p.getX();

        int endY = 0;
        int endX = element.getSize().getWidth();
//        Logger.debug("Device height:" + size.getHeight() + "$$$ Device width:" + size.getWidth());
//        Logger.debug("Element X:" + point.getX() + "$$$ Element Y:" + point.getY());
//        Logger.debug("Element Height:" + element.getSize().height + "$$$$ Element Width:" + element.getSize().width);
//        Logger.debug("end X:" + endX + "$$$$end Y:" + endY);
        TouchAction action = new TouchAction((MobileDriver) driver);
        //action.press(element).moveTo(endX, endY).release().perform();
        action.press((int) (point.getX() + (element.getSize().getWidth() * 0.10)), element.getCenter().getY()).moveTo((int) (screenWidth - (point.getX() + (element.getSize().getWidth() * 0.10))), endY).release().perform();

    }

    public InputStream takeScreenshot() {
        try {
            File screenshotFile = ((TakesScreenshot) driver).getScreenshotAs(OutputType.FILE);

            String appiumScreenshotsDirStr = System.getProperty("appium.screenshots.dir", null);
            if (appiumScreenshotsDirStr != null) {
                // In case the "appium.screenshots.dir" is set, save the screenshot
                // file in that location. This is primarily intended for making
                // the screenshot visible in the AWS Device Farm web UI.
                try {
                    File appiumScreenshotsDir = new File(appiumScreenshotsDirStr);
                    appiumScreenshotsDir.mkdirs();
                    File newScreenshotFile = newScreenshotFile = new File(
                            appiumScreenshotsDirStr,
                            String.format("%s_%s.png",
                                    this.getSession().currentTestName,
                                    new SimpleDateFormat("yyyy-MM-dd_HH-mm-ss").format(new Date())));
                    FileUtils.moveFile(screenshotFile, newScreenshotFile);
                    screenshotFile = newScreenshotFile;
                    Logger.info(String.format("Copied screenshot file to %s", newScreenshotFile.getAbsolutePath()));
                } catch (Exception ex) {
                    Logger.warning(String.format("Failed to copy screenshot file to directory %s", appiumScreenshotsDirStr), ex);
                }
            }

            return new FileInputStream(screenshotFile);
        } catch (Exception ex) {
            Logger.warning("Failed capturing screenshot file", ex);
            return null;
        }
    }

    protected void waitForElementPresent(By locator, long waitIntervalSec) {
        waitForCondition(locator, Condition.PRESENCE_OF_ELEMENT_LOCATED, waitIntervalSec);
    }

    protected void waitForElementVisible(By locator, long waitIntervalSec) throws InterruptedException {
        waitForCondition(locator, Condition.VISIBILITY_OF_ELEMENT_LOCATED, waitIntervalSec);
    }

    protected void waitForCondition(By locator, Condition condition, long waitIntervalSec) {
        try {
            Logger.trace(String.format("AppiumTestAction.waitForCondition (%s, %s, %s)",
                    locator,
                    condition.name(),
                    waitIntervalSec));

            WebDriverWait wait = new WebDriverWait(driver, waitIntervalSec);

            switch (condition) {
                case PRESENCE_OF_ELEMENT_LOCATED:
                    wait.until(ExpectedConditions.presenceOfElementLocated(locator));
                    break;
                case VISIBILITY_OF_ELEMENT_LOCATED:
                    wait.until(ExpectedConditions.visibilityOfElementLocated(locator));
                    break;
                case INVISIBILITY_OF_ELEMENT_LOCATED:
                    wait.until(ExpectedConditions.invisibilityOfElementLocated(locator));
                    break;
            }
        } catch (Exception ex) {
            throw new RuntimeException(String.format("Condition %s failed to verify in %s sec for element %s",
                    condition.name(),
                    waitIntervalSec,
                    locator), ex);
        }
    }

    protected void selectDropDownValue(By locator) {
        System.out.println("INSIDE THE METHOD - SELECTDROPDOWNVALUE");
        //Click on dropdown to open list.
        MobileElement element = getElement(locator);
        element.click();

        By locator1 = By.className("android.widget.TextView");
        //By.xpath("//android.widget.TextView[@text='Medium']");
        //MobileElement element1 = findElement(locator1, 180);
        //element1.click();

        //Locate all drop down list elements 
        List dropList = driver.findElements(locator1);
        //Extract text from each element of drop down list one by one.  
        for (int i = 0; i < dropList.size(); i++) {
            MobileElement listItem = (MobileElement) dropList.get(i);
            System.out.println(listItem.getText());
        }

    }

    protected void endScroll(By locator, String direction) {

        boolean elementWasFound = false;
        boolean swipe = true;
        String lastElement = null;

        while (swipe) {

            try {
                waitForElementVisible(locator, 1);
                elementWasFound = true;
                String message = "Found element " + locator.toString();
                System.out.println(message);
                break;
            } catch (Exception ex) {
                if (direction.equalsIgnoreCase("none")) {
                    throw new RuntimeException(String.format("Element %s not found", locator.toString()));
                }
                /*
                 * if (returnElementPosition(findElement(locator, 1))) {
                 * swipe(direction); } else { break; }
                 */
            }
        }
        if (!elementWasFound) {
            throw new RuntimeException(String.format("Could not find element %s", locator));
        }

    }

    protected void returnElementPosition(MobileElement element) {

        Point point;
        MobileElement element1;

        List<MobileElement> allElements = (List<MobileElement>) element.findElements(By.xpath(".//*"));

        for (int i = 0; i < allElements.size(); i++) {
            element1 = allElements.get(i);
            point = element1.getLocation();

            int x = point.getX();
            int y = point.getY();

            int width = element.getSize().width;
            int height = element.getSize().height;
            break;
        }
    }
}
