package org.getopentest.selenium;

import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.InputStream;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import javax.imageio.ImageIO;
import org.getopentest.selenium.core.SeleniumTestAction;
import org.getopentest.util.ImageCompareResult;
import org.getopentest.util.ImageUtil;
import org.openqa.selenium.By;
import org.openqa.selenium.Dimension;
import org.openqa.selenium.JavascriptExecutor;
import org.openqa.selenium.Point;
import org.openqa.selenium.WebElement;
import ru.yandex.qatools.ashot.AShot;
import ru.yandex.qatools.ashot.Screenshot;
import ru.yandex.qatools.ashot.coordinates.WebDriverCoordsProvider;
import ru.yandex.qatools.ashot.shooting.ShootingStrategies;
import ru.yandex.qatools.ashot.shooting.ShootingStrategy;

public class AssertElementImage extends SeleniumTestAction {

    private BufferedImage screenshotImage;

    /**
     * Capture the image of the target HTML element.
     * @param targetLocator The locator of the HTML element to capture.
     * @param ignoredElements The HTML elements ignored from the comparison.
     * @param scaleFactor For retina displays, this has to be set to 2.
     * @param ignoredPixelsColor The color that will be used to obscure the
     * HTML elements that are ignored from the comparison.
     * @return The image of the HTML element.
     */
    private BufferedImage captureImage(By targetLocator, By[] ignoredElements, Double scaleFactor, Color ignoredPixelsColor) {
        WebElement targetElement = this.getElement(targetLocator);
        ShootingStrategy shootingStrategy = ShootingStrategies.viewportPasting(ShootingStrategies.scaling(scaleFactor.floatValue()), 100);
        AShot ashot = new AShot()
                .coordsProvider(new WebDriverCoordsProvider())
                .shootingStrategy(shootingStrategy);

        // Hide scroll bars, so they don't impact the captured image
        JavascriptExecutor jsExecutor = (JavascriptExecutor) driver;
        Object overflowValue = jsExecutor.executeScript("return document.querySelector('html').style.overflow");
        if (!(overflowValue instanceof String)) {
            overflowValue = "initial";
        }
        jsExecutor.executeScript("document.querySelector('html').style.overflow = 'hidden'");

        Screenshot screenshot = ashot.takeScreenshot(driver, targetElement);
        BufferedImage capturedImage = screenshot.getImage();

        jsExecutor.executeScript(String.format("document.querySelector('html').style.overflow = '%s';", overflowValue));

        for (By by : ignoredElements) {
            Point targetElemLocation = targetElement.getLocation();

            WebElement ignoredElement = this.getElement(by);
            Point ignoredElementLocation = ignoredElement.getLocation();

            Dimension size = ignoredElement.getSize();
            int width = size.width;
            int height = size.height;

            int relativeX = ignoredElementLocation.getX() - targetElemLocation.getX();
            int relativeY = ignoredElementLocation.getY() - targetElemLocation.getY();

            for (int xCoord = relativeX; xCoord < relativeX + width; xCoord++) {
                for (int yCoord = relativeY; yCoord < relativeY + height; yCoord++) {
                    capturedImage.setRGB(xCoord, yCoord, ignoredPixelsColor.getRGB());
                }
            }
        }

        return capturedImage;
    }

    @Override
    public void run() {
        By targetLocator = this.readLocatorArgument("locator");
        List<String> expectedImagePaths = this.readArrayArgument("expectedImage", String.class);
        By[] ignoredElements = this.readLocatorArguments("ignoredElements", new By[0]);
        Double expectedSimilarity = this.readDoubleArgument("expectedSimilarity", 0.99);
        Double colorMatchTolerance = this.readDoubleArgument("colorMatchTolerance", 0.15);
        Double scaleFactor = this.readDoubleArgument("scaleFactor", 1d);

        this.waitForAsyncCallsToFinish();

        Color ignoredPixelsColor = Color.decode("#FF00EE"); // shade of magenta
        BufferedImage capturedImage = captureImage(targetLocator, ignoredElements, scaleFactor, ignoredPixelsColor);

        double bestSimilarity = 0;
        BufferedImage bestSimilarityTemplateImage = null;
        BufferedImage bestSimilarityDiffImage = null;
        long bestSimilarityDiffPixelCount = 0;

        // Iterate through all template images in search of one that matches the
        // expected similarity
        for (String imagePath : expectedImagePaths) {
            BufferedImage templateImage = null;
            try {
                templateImage = this.getActor().getImage(imagePath);
            } catch (Exception exc) {
                this.log.error(String.format("Failed to load image %s", imagePath), exc);
                continue;
            }

            ImageCompareResult compareResult = ImageUtil.compare(templateImage, capturedImage, colorMatchTolerance, ignoredPixelsColor);

            if (compareResult.getSimilarity() > bestSimilarity) {
                bestSimilarity = compareResult.getSimilarity();
                bestSimilarityDiffImage = compareResult.getDiffImage();
                bestSimilarityTemplateImage = templateImage;
                bestSimilarityDiffPixelCount = compareResult.getDiffPixelCount();

                if (compareResult.getSimilarity() >= expectedSimilarity) {
                    break;
                }
            }
        }

        if (bestSimilarity < expectedSimilarity) {
            // Write screen capture to disk
            try {
                String timestamp = LocalDateTime.now()
                        .format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH-mm-ss"));

                Path capturePath = Paths.get(
                        this.getActor().getOutDir().getAbsolutePath(),
                        "selenium",
                        this.getClass().getSimpleName(),
                        timestamp + ".png");

                File captureFile = capturePath.toFile();
                captureFile.mkdirs();
                ImageIO.write(capturedImage, "PNG", captureFile);

                // Build screenshot to be shown in the test results by stiching
                // together three images: expected, actual and diff.
                int screenshotHeight = bestSimilarityDiffImage.getHeight();
                this.screenshotImage = new BufferedImage(
                        bestSimilarityTemplateImage.getWidth() + capturedImage.getWidth() + bestSimilarityDiffImage.getWidth() + 10,
                        screenshotHeight,
                        BufferedImage.TYPE_3BYTE_BGR);
                int currentX = 0;
                Color yellowColor = Color.decode("#FDF84F");
                Graphics2D screenshotGraphics = this.screenshotImage.createGraphics();
                screenshotGraphics.setColor(yellowColor);
                screenshotGraphics.drawImage(bestSimilarityTemplateImage, null, currentX, 0);
                currentX += bestSimilarityTemplateImage.getWidth();
                screenshotGraphics.fillRect(currentX, 0, 5, screenshotHeight);
                currentX += 5;
                screenshotGraphics.drawImage(capturedImage, null, currentX, 0);
                currentX += capturedImage.getWidth();
                screenshotGraphics.fillRect(currentX, 0, 5, screenshotHeight);
                currentX += 5;
                screenshotGraphics.drawImage(bestSimilarityDiffImage, null, currentX, 0);
            } catch (Exception exc) {
                this.screenshotImage = bestSimilarityDiffImage;
            }

            throw new RuntimeException(String.format(
                    "Screen capture did not match the provided template image(s). "
                    + "Expected simillarity was %.5f, but actual similarity "
                    + "was %.5f. We found %s pixels that were different "
                    + "between the expected and actual image.",
                    expectedSimilarity,
                    bestSimilarity,
                    bestSimilarityDiffPixelCount));
        }
    }

    @Override
    public InputStream takeScreenshot() {
        if (this.screenshotImage == null) {
            return null;
        } else {
            try {
                ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
                ImageIO.write(this.screenshotImage, "png", outputStream);
                InputStream inputStream = new ByteArrayInputStream(outputStream.toByteArray());
                return inputStream;
            } catch (Exception exc) {
                return null;
            }
        }
    }
}
