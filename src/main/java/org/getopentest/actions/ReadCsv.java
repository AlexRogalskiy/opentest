package org.getopentest.actions;

import java.io.FileInputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.io.StringReader;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import org.apache.commons.codec.CharEncoding;
import org.apache.commons.codec.Charsets;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVRecord;
import org.apache.commons.io.input.BOMInputStream;
import org.getopentest.annotations.TestActionArgument;
import org.getopentest.annotations.TestArgumentType;
import org.getopentest.base.TestAction;

@TestActionArgument(name = "file", type = TestArgumentType.STRING, optional = true)
@TestActionArgument(name = "csv", type = TestArgumentType.STRING, optional = true)
@TestActionArgument(name = "hasBom", type = TestArgumentType.BOOLEAN, optional = true, defaultValue = "false",
        description = "Specifies whether the file starts with a Byte Order Mark (BOM).")
@TestActionArgument(name = "hasHeader", type = TestArgumentType.BOOLEAN, optional = true, defaultValue = "true",
        description = "Specifies whether the CSV data starts with a header row.")
@TestActionArgument(name = "format", type = TestArgumentType.STRING, optional = true, defaultValue = "default")
@TestActionArgument(name = "fieldNames", type = TestArgumentType.ARRAY, optional = true, defaultValue = "null")
/**
 * An action that parses CSV data and returns its lines as an array of objects.
 */
public class ReadCsv extends TestAction {

    @Override
    public void run() {
        super.run();

        String filePath = this.readStringArgument("file", null);
        String csvString = this.readStringArgument("csv", null);
        Boolean hasBom = this.readBooleanArgument("hasBom", Boolean.FALSE);
        Boolean hasHeader = this.readBooleanArgument("hasHeader", Boolean.TRUE);
        String format = this.readStringArgument("format", "default");
        List<String> fieldNames = this.readArrayArgument("fieldNames", String.class, null);

        try {

            Reader csvReader;
            if (filePath != null) {
                if (hasBom) {
                    csvReader = new InputStreamReader(new BOMInputStream(new FileInputStream(filePath)), CharEncoding.UTF_8);
                } else {
                    csvReader = Files.newBufferedReader(Paths.get(filePath), Charsets.UTF_8);
                }
            } else if (csvString != null) {
                csvReader = new StringReader(csvString);
            } else {
                throw new RuntimeException("Neither the \"file\" argument, nor the \"csv\" argument were provided.");
            }

            CSVFormat csvFormat = this.getCsvFormat(format);

            if (hasHeader) {
                csvFormat = csvFormat.withFirstRecordAsHeader();
            }

            List<Map<String, String>> recordsArray = new ArrayList<>();
            Iterable<CSVRecord> records = csvFormat.parse(csvReader);

            for (CSVRecord record : records) {
                if (hasHeader) {
                    recordsArray.add(record.toMap());
                } else {
                    Map<String, String> recordsMap = new HashMap<>();
                    Iterator<String> fields = record.iterator();
                    int columnNo = 1;
                    while (fields.hasNext()) {
                        String field = fields.next();
                        if (fieldNames != null && fieldNames.size() >= columnNo && fieldNames.get(columnNo - 1) != null) {
                            recordsMap.put(fieldNames.get(columnNo - 1).trim(), field);
                        } else {
                            recordsMap.put(String.format("col%s", columnNo), field);
                        }

                        columnNo++;
                    }
                    recordsArray.add(recordsMap);
                }
            }

            this.writeOutput("records", recordsArray);
        } catch (Exception ex) {
            throw new RuntimeException("Failed to parse CSV", ex);
        }
    }

    /**
     * Returns a CSVFormat object given the CSV format as a string.
     *
     * @param format
     * @return
     */
    private CSVFormat getCsvFormat(String format) {
        CSVFormat csvFormat = null;

        switch (format.trim().toLowerCase()) {
            case "default":
                csvFormat = CSVFormat.DEFAULT;
                break;
            case "excel":
                csvFormat = CSVFormat.EXCEL;
                break;
            case "informixunload":
            case "informix-unload":
            case "informix_unload":
                csvFormat = CSVFormat.INFORMIX_UNLOAD;
                break;
            case "informixunloadcsv":
            case "informix-unload-csv":
            case "informix_unload_csv":
                csvFormat = CSVFormat.INFORMIX_UNLOAD_CSV;
                break;
            case "mysql":
                csvFormat = CSVFormat.MYSQL;
                break;
            case "postgres":
            case "postgresql-csv":
            case "postgresql_csv":
                csvFormat = CSVFormat.POSTGRESQL_CSV;
                break;
            case "postgresql-text":
            case "postgresql_text":
                csvFormat = CSVFormat.POSTGRESQL_TEXT;
                break;
            case "rfc4180":
                csvFormat = CSVFormat.RFC4180;
            case "tdf":
                csvFormat = CSVFormat.TDF;
            default:
                throw new RuntimeException(String.format("CSV format \"%s\" is not among the supported formats"));
        }

        return csvFormat;
    }
}
