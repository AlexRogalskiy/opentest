package dtest.actor;

import com.google.gson.*;
import dtest.actor.yaml.SkipNullRepresenter;
import dtest.base.TestAction;
import dtest.base.TestSession;
import dtest.base.contracts.ILogger;
import dtest.base.contracts.ITestActor;
import dtest.base.exceptions.ParameterNotFoundException;
import dtest.base.http.ContentType;
import dtest.base.http.HttpRequest;
import dtest.base.http.HttpVerb;
import dtest.base.logging.ConsoleLogger;
import dtest.base.logging.HttpLogger;
import dtest.base.logging.LogLevel;
import dtest.base.logging.Logger;
import dtest.base.testdef.MacroDefinition;
import dtest.base.testdef.TestDefAction;
import dtest.base.testdef.TestDefActor;
import dtest.base.testdef.TestDefStep;
import dtest.base.testdef.TestDefinition;
import dtest.base.util.Configuration;
import dtest.base.util.MainUtil;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.Field;
import java.math.BigInteger;
import java.net.URLEncoder;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.SecureRandom;
import java.time.Duration;
import java.util.*;
import java.util.function.BiFunction;
import java.util.function.Function;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;
import jdk.nashorn.api.scripting.AbstractJSObject;
import jdk.nashorn.internal.runtime.Undefined;
import org.yaml.snakeyaml.DumperOptions;
import org.yaml.snakeyaml.Yaml;
import org.yaml.snakeyaml.nodes.Tag;
import org.yaml.snakeyaml.parser.ParserException;

/**
 * Implements the core functionality for a test actor: reads the configuration
 * from a properties file, announces the actor to the sync service, then
 * identifies, parses and executes the tests, as orchestrated by the sync
 * service.
 */
public class TestActor implements ITestActor {

    /**
     * Implementation of the $sharedData function exposed in JavaScript.
     */
    public class SharedDataFunction extends AbstractJSObject {

        public SharedDataFunction() {
        }

        @Override
        public boolean isFunction() {
            return true;
        }

        @Override
        public Object call(Object thiz, Object... args) {
            if (args.length == 1) {
                String url = String.format("%s/api/session/%s/test/%s/data",
                        syncServiceBaseUrl,
                        currentTestSession.id,
                        currentTestSession.currentTestIndex);

                try {
                    HttpRequest request = new HttpRequest(url, HttpVerb.GET);
                    request.execute();
                    Map<String, Object> sharedData = new Gson().fromJson(request.getResponseAsString(), Map.class);
                    return sharedData.get(args[0]);
                } catch (Exception ex) {
                    throw new RuntimeException(String.format("There was an error while requesting the test shared data from the sync service. HTTP request details: %s",
                            "GET " + url));
                }
            } else if (args.length == 2) {
                try {
                    publishSharedData(args[0].toString(), args[1]);
                } catch (Exception ex) {
                    throw new RuntimeException(String.format(
                            "There was an error while publishing the test shared data to the sync service."), ex);
                }
            }

            return Undefined.getUndefined();
        }
    }

    /**
     * The string identifier of the actor.
     */
    private String actorId;

    /**
     * Identifies the type of actor (GMA, NP6, etc.).
     */
    private final String actorType;

    private long announceCount = 0;

    /**
     * The last exception that was thrown while announcing the actor.
     */
    private Exception announceException = null;

    private Thread announceThread;

    /**
     * Flags all threads and activities to shut down.
     */
    private boolean actorIsStopping;

    private Properties config;

    /**
     * The test action instance that is currently being executed, or null.
     */
    private TestAction currentAction;

    private String currentScript;

    private boolean currentStepIsCompleted;

    private TestDefinition currentTest;

    /**
     * Stores information about the current test session, if any. If not null,
     * it means that this test actor was acquired by the sync service and
     * allocated to a particular test session
     */
    private TestSession currentTestSession;

    /**
     * Caches the content of data files used in the tests, as soon as a test
     * first reads a value from a data file. The cache is reset at the beginning
     * of each test session.
     */
    private Map<String, Object> dataFileCache;

    private ILogger log;

    /**
     * The arguments for the current macro action being executed (if any).
     */
    private Map<String, Object> macroArgs;

    /**
     * Caches macro definitions so we don't have to load them from disk every
     * time they're used.
     */
    private Map<String, MacroDefinition> macroCache;

    private ScriptEngine scriptEngine;

    private final String syncServiceBaseUrl;

    private final String testRepoDirName;

    private String testRepoLocation;

    public TestActor() {
        this(null);
    }

    public TestActor(Map<Object, Object> configOverrides) {
        ConsoleLogger consoleLogger = new ConsoleLogger();
        this.log = consoleLogger;
        this.log.info("");

        Logger.setLogger(this.log);

        try {
            this.config = Configuration.getConfiguration("actor.properties");
        } catch (Exception ex) {
            // Also support TestActor.properties file name, just in case
            this.config = Configuration.getConfiguration("TestActor.properties");
        }

        if (configOverrides != null) {
            this.config.putAll(configOverrides);
        }

        consoleLogger.setLevel(LogLevel.valueOf(config.getProperty("logLevel", "DEBUG")));

        try {
            // The configuration is loaded from the main JAR file's resources, so
            // we are logging the main class name so we can troubleshoot later
            Class<?> mainClass = MainUtil.getMainClass();
            Logger.trace(String.format("The main class is %s", mainClass.getName()));
        } catch (Exception ex) {
        }

        this.actorId = getStringParameter("actorId", "");
        this.actorType = getStringParameter("actorType");
        this.syncServiceBaseUrl = getStringParameter("syncServiceBaseUrl").replaceAll("^[\\s]+|[/\\s]+$", "");

        this.testRepoDirName = getStringParameter("testRepoDirName", "").replaceAll("^[\\\\/\\s]+|[\\\\\\/\\s]+$", "");
        this.testRepoLocation = getStringParameter("testRepoLocation", "");
        this.testRepoLocation = this.testRepoLocation.replaceAll("^[\\s]+|[\\\\\\/\\s]+$", "");

//        if (!new File(testRepoLocation).exists()) {
//            throw new RuntimeException("The test repository directory could not be found. You can use the testRepoLocation parameter to configure it.");
//        }
        if (this.actorId == null || this.actorId.isEmpty()) {
            SecureRandom random = new SecureRandom();
            this.actorId = new BigInteger(16, random).toString(10);
        }
        this.actorIsStopping = false;
        this.currentTestSession = null;

        startAnnounceThread();
    }

    private void abandonSession() {
        this.currentTestSession = null;
    }

    /**
     * Announces the actor to the sync service, so it can be used for running a
     * test session.
     */
    private void announce() {
        ++announceCount;

        try {
            HttpRequest request = new HttpRequest(syncServiceBaseUrl + "/api/actor/announce", HttpVerb.POST);
            request.setContent(String.format("{\"actorId\":\"%s\",\"actorType\":\"%s\"}", actorId, actorType), ContentType.APPLICATION_JSON);
            request.execute();

            Integer statusCode = request.getResponseStatusCode();
            if (statusCode == null || statusCode != 200) {
                throw new RuntimeException(String.format("Failed to announce actor %s%s to the sync service. The HTTP request was %s %s. The response status code was %s.",
                        this.actorType,
                        this.actorId != null ? String.format("(%s)", this.actorId) : "",
                        request.getHttpVerb(),
                        request.getUri(),
                        statusCode != null ? statusCode : "(not available)"));
            }

            String response = request.getResponseAsString();
            JsonElement jelement = new JsonParser().parse(response);
            JsonElement testSessionIdElem = jelement.getAsJsonObject().get("testSessionId");

            if (testSessionIdElem != null && !testSessionIdElem.isJsonNull()) {
                String testSessionId = testSessionIdElem.getAsString();
                String currentSessionId = this.currentTestSession != null
                        ? this.currentTestSession.id
                        : null;

                if (this.currentTestSession == null) {
                    Logger.trace("Initializing test session information in the \"announce\" method...");
                    Logger.trace(String.format("Session ID in sync server response was %s; actor session ID was %s",
                            testSessionId,
                            currentSessionId));
                    this.currentTestSession = new TestSession(testSessionId);
                }
            } else {
                this.currentTestSession = null;
            }

            // Publish actor catalog, but only the very first time or after we had
            // some error announcing the actor (maybe a network-related issue)
            if (announceCount == 1 || announceException != null) {
                try {
                    ActorCatalog catalog = ActorCatalogBuilder.buildCatalog(Paths.get(testRepoLocation, testRepoDirName).toString());
                    Gson gson = new Gson();
                    String json = gson.toJson(catalog);

                    System.out.println("Sending test catalog data to the sync service...");
                    String url = String.format("%s/api/actor/%s/catalog",
                            syncServiceBaseUrl, actorId);
                    HttpRequest catalogRequest = new HttpRequest(url, HttpVerb.POST);
                    catalogRequest.setContent(json, ContentType.APPLICATION_JSON);
                    catalogRequest.execute();
                    System.out.println(String.format("Sent %s test catalog entries", catalog.tests.size()));
                } catch (Exception ex) {
                    String errorMessage = ex.getMessage();
                    log.warning("Failed to build test catalog. " + (errorMessage != null ? errorMessage : ""));
                }
            }

            announceException = null;
        } catch (Exception ex) {
            announceException = ex;
            ex.printStackTrace();

            try {
                Thread.sleep(10000);
            } catch (InterruptedException ex1) {
            }
        }
    }

    /**
     * Sets a flag that signals all threads and activities for this actor to
     * shut down.
     */
    @Override
    public void close() {
        actorIsStopping = true;
    }

    private Object evalScriptFile(String scriptFileFullPath) throws ScriptException, FileNotFoundException {
        Path scriptPath = Paths.get(scriptFileFullPath);

        if (Files.exists(scriptPath)) {
            this.currentScript = scriptPath.toString();
        }

        return this.scriptEngine.eval(new FileReader(scriptPath.toString()));
    }

    /**
     * Executes an action and returns the output values produced by the action.
     */
    private Map<String, Object> executeAction(String actionClassName, Map<String, Object> args) throws Exception {
        if (args.containsKey("executeIf") && args.get("executeIf") != Boolean.TRUE) {
            Logger.debug(String.format("Skipping conditional action %s", actionClassName));
            return new HashMap<>();
        }

        Class actionClass;
        actionClass = Class.forName(actionClassName);

        if (TestAction.class.isAssignableFrom(actionClass)) {
            TestAction actionInstance = (TestAction) actionClass.newInstance();
            actionInstance.setSession(new TestSession(this.currentTestSession));
            this.currentAction = actionInstance;

            // Inject the logger instance into the action
            Field[] fields = TestAction.class.getDeclaredFields();
            for (Field f : fields) {
                if (f.getType().isAssignableFrom(ILogger.class)) {
                    f.setAccessible(true);
                    f.set(actionInstance, this.log);
                    f.setAccessible(false);
                }
            }

            if (args != null) {
                for (Map.Entry<String, Object> entry : args.entrySet()) {
                    actionInstance.writeArgument(entry.getKey(), entry.getValue());
                }
            }

            actionInstance.initialize();

            try {
                Logger.trace(String.format("Executing action %s with arguments %s...",
                        actionClass.getName(),
                        actionInstance.getArgs()));
                actionInstance.run();
            } catch (Exception ex) {
                if (actionInstance.isOptional()) {
                    Logger.debug(String.format(
                            "Optional action %s failed. Execution will continue.",
                            actionInstance.getClass().getName()));
                } else {
                    throw ex;
                }
            }

            return actionInstance.getOutput();
        } else {
            throw new RuntimeException(String.format("Class %s is not a test action class and cannot be used in test definitions",
                    actionClassName));
        }
    }

    private Map<String, Object> executeAction(TestDefAction actionDef) {
        try {
            // Added for backward compatibility and will be removed eventually
            if (actionDef.action == null) {
                actionDef.action = actionDef.type;
                actionDef.type = null;
            }

            Map<String, Object> actionArgs = evalActionArgs(actionDef.args);

            if (actionArgs.containsKey("executeIf") && actionArgs.get("executeIf") != Boolean.TRUE) {
                String actionName = actionDef.action != null
                        ? actionDef.action
                        : actionDef.script != null
                                ? ScriptAction.class.getName()
                                : actionDef.macro != null
                                        ? MacroAction.class.getName()
                                        : "(unknown)";
                Logger.debug(String.format("Skipping conditional action %s", actionName));
                return new HashMap<String, Object>();
            }

            Map<String, Object> outputValues = null;

            if (actionDef.action != null) {
                // REGULAR ACTION
                outputValues = executeAction(actionDef.action, actionArgs);
            } else if (actionDef.script != null) {
                // SCRIPT ACTION
                actionDef.action = ScriptAction.class.getName();

                try {
                    scriptEngine.eval(actionDef.script);
                } catch (ScriptException ex) {
                    throw new RuntimeException(String.format(
                            "There was an error executing a script while processing a script action. The script content was: %s",
                            actionDef.script), ex);
                }
            } else if (actionDef.macro != null) {
                // MACRO ACTION
                try {
                    String macroPartialPath = actionDef.macro.replaceAll("[\\.\\\\]", "/");
                    MacroDefinition macroDef = getMacroDefinition(macroPartialPath);
                    macroDef.fullName = actionDef.macro;
                    outputValues = executeMacroAction(macroDef, actionArgs);
                } catch (Exception ex) {
                    throw new Exception(String.format("There was an error executing macro action %s",
                            actionDef.macro), ex);
                }
            }

            // Interpret and publish values in the test's shared data
            if (actionDef.sharedData != null) {
                Map<String, Object> sharedData = new HashMap<String, Object>();

                for (Map.Entry<String, Object> entry : actionDef.sharedData.entrySet()) {
                    sharedData.put(entry.getKey(), interpretValue(entry.getValue().toString()));
                }

                publishSharedData(sharedData);
            }

            if (outputValues == null) {
                outputValues = new HashMap<String, Object>();
            }

            return outputValues;
        } catch (ClassNotFoundException ex) {
            throw new RuntimeException(String.format(
                    "Failed to find action class \"%s\". Make sure the action type is correct in the test definition file and the JAR file where the class is implemented exists in the CLASSPATH",
                    actionDef.action), ex);
        } catch (InstantiationException | IllegalAccessException ex) {
            throw new RuntimeException(String.format(
                    "Failed to instantiate action class \"%s\"",
                    actionDef.action), ex);
        } catch (Exception ex) {
            String actionName = actionDef.action != null
                    ? actionDef.action
                    : actionDef.macro != null
                            ? actionDef.macro
                            : actionDef.script != null ? "of type \"script\"" : "?";

            String actionArguments;
            if (this.currentAction != null) {
                Gson gson = new Gson();
                JsonObject jsonObject = new JsonObject();

                String[] argNames = this.currentAction.getArgNames();
                if (argNames.length > 0) {
                    actionArguments = this.currentAction.getArgs().toString();
                } else {
                    actionArguments = "(no arguments provided)";
                }
            } else {
                actionArguments = "N/A (current action instance was null)";
            }

            throw new RuntimeException(String.format(
                    "Failed executing action %s with arguments %s",
                    actionName,
                    actionArguments), ex);
        }
    }

    private Map<String, Object> executeMacroAction(MacroDefinition macroDef, Map<String, Object> macroArgs) throws Exception {
        this.macroArgs = macroArgs;

        Logger.trace(String.format("Executing macro %s with arguments %s...",
                macroDef.fullName,
                macroArgs));

        // Execute the actions for the current macro, in the order
        // they appear in the macro definition file
        if (macroDef.actions != null) {
            for (TestDefAction actionDef : macroDef.actions) {
                try {
                    log.debug(String.format("Executing action %s/%s of macro %s%s...",
                            macroDef.actions.indexOf(actionDef),
                            macroDef.actions.size(),
                            macroDef.fullName,
                            actionDef.description != null
                                    ? String.format(" (%s)", actionDef.description)
                                    : ""));
                    executeAction(actionDef);
                } catch (Exception ex) {
                    final DumperOptions options = new DumperOptions();
                    options.setDefaultFlowStyle(DumperOptions.FlowStyle.FLOW);
                    options.setPrettyFlow(true);

                    SkipNullRepresenter representer = new SkipNullRepresenter();
                    representer.addClassTag(TestDefAction.class, Tag.MAP);

                    Yaml yaml = new Yaml(representer, options);
                    String actionDefYaml = yaml.dump(actionDef);

                    throw new RuntimeException(String.format(
                            "There was an error while executing action %s (with index %s) in macro %s.\nThe action definition was:\n%s",
                            actionDef.action,
                            macroDef.actions.indexOf(actionDef),
                            macroDef.fullName,
                            actionDefYaml), ex);
                }
            }
        }

        // TODO: Return the actual macro output values
        return null;
    }

    private void executeTestStep(int stepIndex) throws Exception {
        // Notify the sync service that the step execution is starting
        HttpRequest stepStatusRequest = new HttpRequest(
                String.format("%s/api/session/%s/actor/%s/test/%s/step/%s",
                        syncServiceBaseUrl,
                        this.currentTestSession.id,
                        actorId,
                        this.currentTestSession.currentTestIndex,
                        stepIndex),
                HttpVerb.PUT);
        stepStatusRequest.setContent("{\"status\":\"started\",\"result\":\"pending\"}", ContentType.APPLICATION_JSON);
        stepStatusRequest.execute();

        try {
            // Identify the actor node in the test definition data
            Optional<TestDefActor> testDefActorOpt = currentTest.actors.stream()
                    .filter(a -> a.actorType.equals(this.actorType)).findFirst();
            if (testDefActorOpt.isPresent()) {
                Optional<TestDefStep> testDefStepOpt = testDefActorOpt.get().steps.stream()
                        .filter(s -> s.step == stepIndex).findFirst();
                if (testDefStepOpt.isPresent() && (testDefStepOpt.get().actions != null)) {
                    log.info(String.format("Executing step %s of test %s/%s...",
                            stepIndex,
                            this.currentTestSession.currentTestPath,
                            this.currentTestSession.currentTestName));

                    // Execute the actions for the current step, in the order
                    // they appear in the test definition file
                    List<TestDefAction> stepActions = testDefStepOpt.get().actions;
                    for (TestDefAction actionDef : stepActions) {
                        try {
                            log.info(String.format("Executing action %s of step %s%s...",
                                    stepActions.indexOf(actionDef),
                                    stepIndex,
                                    actionDef.description != null
                                            ? String.format(" (%s)", actionDef.description)
                                            : ""));
                            executeAction(actionDef);
                        } catch (Exception ex) {
                            if (this.currentAction != null) {
                                InputStream screenshotStream = this.currentAction.takeScreenshot();
                                if (screenshotStream != null) {
                                    // TODO: Send screenshot to sync service
                                }
                            }

                            String actionName = actionDef.action != null
                                    ? actionDef.action
                                    : actionDef.macro != null
                                            ? actionDef.macro
                                            : actionDef.script != null ? "of type script" : "?";

                            final DumperOptions options = new DumperOptions();
                            options.setDefaultFlowStyle(DumperOptions.FlowStyle.FLOW);
                            options.setPrettyFlow(true);

                            SkipNullRepresenter representer = new SkipNullRepresenter();
                            representer.addClassTag(TestDefAction.class, Tag.MAP);

                            Yaml yaml = new Yaml(representer, options);
                            String actionDefYaml = yaml.dump(actionDef);

                            throw new RuntimeException(String.format(
                                    "There was an error while executing action %s (with index %s) in step %s of test %s/%s.\nThe action definition was:\n%s",
                                    actionName,
                                    testDefStepOpt.get().actions.indexOf(actionDef),
                                    stepIndex,
                                    this.currentTestSession.currentTestPath,
                                    this.currentTestSession.currentTestName,
                                    actionDefYaml), ex);
                        } finally {
                            this.currentAction = null;
                        }
                    }
                }
            }

            // Notify the sync service that the step execution was completed
            stepStatusRequest.setContent("{\"status\":\"completed\",\"result\":\"passed\"}", ContentType.APPLICATION_JSON);
            stepStatusRequest.execute();
        } catch (Exception ex) {
            // Notify the sync service that the step execution failed
            Map<String, String> content = new HashMap<String, String>();
            content.put("status", "completed");
            content.put("result", "failed");
            content.put("details", Logger.getStackTrace(ex));

            Gson gson = new Gson();
            stepStatusRequest.setContent(gson.toJson(content), ContentType.APPLICATION_JSON);
            stepStatusRequest.execute();

            Exception newException = new Exception(String.format("Failed executing test %s/%s, step %s",
                    this.currentTestSession.currentTestPath,
                    this.currentTestSession.currentTestName,
                    stepIndex), ex);
            throw newException;
        }
    }

    /**
     * Evaluate action arguments values as JavaScript (if applicable) and return
     * a new Map with the evaluated values
     * @param originalActionArgs The arguments as they appear in the test definition
     */
    private Map<String, Object> evalActionArgs(Map<String, Object> originalActionArgs) {
        Map<String, Object> actionArgs = new HashMap<String, Object>();
        
        if (originalActionArgs != null) {
            for (Map.Entry<String, Object> entry : originalActionArgs.entrySet()) {
                try {
                    Object argValue = entry.getValue();
                    if (argValue instanceof Map) {
                        actionArgs.put(entry.getKey(), evalActionArgs((Map)argValue));
                    } else {
                        String stringValue = entry.getValue().toString();
                        actionArgs.put(entry.getKey(), interpretValue(stringValue));
                    }
                } catch (Exception ex) {
                    throw new RuntimeException(String.format(
                            "There was an error while processing argument \"%s\"",
                            entry.getKey()), ex);
                }
            }
        }
        
        return actionArgs;
    }

    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        close();
    }

    /**
     * Determines whether a string value is a script and returns the interpreted
     * value of that string if it's a script, or the plain string value
     * otherwise.
     */
    private Object interpretValue(String value) {
        if (value.matches("(?s)^[\\s\\n]*(\\$data|\\$script|\\$macroArgs|\\$sharedData|\\$readOutput).*")) {
            // Remove the $script syntax from the beggining of the string
            value = value.replaceAll("^\\s*\\$script\\s*", "");

            try {
                return scriptEngine.eval(value);
            } catch (ScriptException ex) {
                throw new RuntimeException(String.format(
                        "An error was encountered while executing a script. The script content was: %s",
                        value), ex);
            }
        } else {
            return value;
        }
    }

    private String getDataDirFullPath() {
        // TODO: Read test-repo.yaml

        return Paths.get(testRepoLocation, testRepoDirName, "data").toString();
    }

    private String getMacroDirFullPath() {
        // TODO: Read test-repo.yaml

        String macroDirFullPath;
        File macroDirFile;

        // First look for the /macros directory
        macroDirFullPath = Paths.get(testRepoLocation, testRepoDirName, "macros").toString();
        macroDirFile = new File(macroDirFullPath);
        if (macroDirFile.exists()) {
            return macroDirFullPath;
        } else {
            // Then look for the /libs/macros directory
            macroDirFullPath = Paths.get(testRepoLocation, testRepoDirName, "libs", "macros").toString();
            macroDirFile = new File(macroDirFullPath);
            if (macroDirFile.exists()) {
                return macroDirFullPath;
            } else {
                // Finally just return the default macro path
                return Paths.get(testRepoLocation, testRepoDirName, "macros").toString();
            }
        }
    }

    private String getScriptssDirFullPath() {
        // TODO: Read test-repo.yaml
        return Paths.get(testRepoLocation, testRepoDirName, "libs", "scripts").toString();
    }

    private String getStringParameter(String parmeterName, String defaultValue) throws ParameterNotFoundException {
        String parameterValue = config.getProperty(parmeterName);
        if (parameterValue != null) {
            return parameterValue;
        } else if (defaultValue != null) {
            return defaultValue;
        } else {
            throw new ParameterNotFoundException(String.format("Parameter %s was not found", parmeterName));
        }
    }

    private String getStringParameter(String parmeterName) {
        return getStringParameter(parmeterName, null);
    }

    /**
     * Queries the sync service for the definition of the specified test asset
     * and returns an input stream with the content of that asset.
     */
    private InputStream getTestAsset(String assetType, String partialPath) {
        // URL-encode the partial path
        String urlEncodedPartialPath = null;
        try {
            urlEncodedPartialPath = URLEncoder.encode(partialPath, "UTF-8");
        } catch (UnsupportedEncodingException ex) {
            throw new RuntimeException(String.format("Failed encoding partial path %s",
                    partialPath), ex);
        }

        // Prepare HTTP request
        String url = String.format(syncServiceBaseUrl + "/api/test-asset?type=%s&path=%s",
                assetType,
                urlEncodedPartialPath);
        HttpRequest request = new HttpRequest(url, HttpVerb.GET);

        try {
            request.execute();
        } catch (Exception ex) {
            throw new RuntimeException(String.format(
                    "An error occured while making the HTTP request to get %s asset %s from the sync service",
                    assetType,
                    partialPath), ex);
        }

        if (request.getResponseStatusCode() == 200) {
            try {
                return request.getResponseAsStream();
            } catch (Exception ex) {
                throw new RuntimeException(String.format(
                        "An error occured while retrieving the HTTP response input stream for %s asset %s from the sync service",
                        assetType,
                        partialPath), ex);
            }
        } else {
            throw new RuntimeException(String.format("Failed to get %s asset %s from the sync service. The HTTP status code was: %s. The HTTP body was: %s",
                    assetType,
                    partialPath,
                    request.getResponseStatusCode(),
                    request.getResponseAsString()));
        }
    }

    private MacroDefinition getMacroDefinition(String partialPath) {
        Yaml yaml = new Yaml();
        MacroDefinition def = yaml.loadAs(getTestAsset("macro", partialPath), MacroDefinition.class);
        return def;
    }

    private TestDefinition getTestDefinition(String partialPath) {
        Yaml yaml = new Yaml();
        TestDefinition def = yaml.loadAs(getTestAsset("test", partialPath), TestDefinition.class);

        // Account for usage of obsolete "index" property in the step definition
        // and just transfer its value to the correct property - "step".
        for (TestDefActor actor : def.actors) {
            for (TestDefStep step : actor.steps) {
                if (step.step == null) {
                    step.step = step.index;
                }
            }
        }
        return def;
    }

    private String getTestsDirFullPath() {
        // TODO: Read test-repo.yaml
        return Paths.get(testRepoLocation, testRepoDirName, "tests").toString();
    }

    private SessionStatusResponse getTestSessionStatus() {
        try {
            SessionStatusResponse sessionStatus = new SessionStatusResponse();

            HttpRequest request = new HttpRequest(
                    String.format("%s/api/session/%s/status",
                            syncServiceBaseUrl,
                            this.currentTestSession.id),
                    HttpVerb.GET);
            request.execute();
            Integer statusCode = request.getResponseStatusCode();

            if (statusCode < 300) {
                String responseString = request.getResponseAsString();
                if (responseString != null) {
                    JsonElement responseElement = new JsonParser().parse(responseString);
                    JsonObject responseObj = responseElement.getAsJsonObject();
                    sessionStatus.status = responseObj.get("status").getAsString();
                    if (sessionStatus.status.equals("started")) {
                        sessionStatus.currentIteration = responseObj.get("currentIteration").getAsInt();
                        sessionStatus.currentStepIndex = responseObj.get("currentStepIndex").getAsInt();
                        sessionStatus.currentTestPath = responseObj.get("currentTestPath").getAsString();
                        sessionStatus.currentTestIndex = responseObj.get("currentTestIndex").getAsInt();
                        sessionStatus.currentTestName = responseObj.get("currentTestName").getAsString();
                    }

                    return sessionStatus;
                }
            } else if (statusCode == 404) {
                // When we receive a 404, it means the session died
                abandonSession();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

        return null;
    }

    /**
     * Initialize the JavaScript interpreter that will be used to evaluate
     * action arguments and run "script" test actions.
     */
    private void initializeScriptEngine() {
        this.scriptEngine = new ScriptEngineManager().getEngineByName("nashorn");

        // Keeping a final reference to the current actor instance, so that we
        // can access it from anonymous classes below
        final TestActor actor = this;

        // $data
        this.scriptEngine.put("$data", new Function<String, Object>() {
            @Override
            public Object apply(String relativePath) {
                if (dataFileCache.containsKey(relativePath)) {
                    return dataFileCache.get(relativePath);
                } else {
                    try {
                        Yaml yaml = new Yaml();
                        Object dataFileContent = yaml.load(getTestAsset("data", relativePath));
                        dataFileCache.put(relativePath, dataFileContent);
                        return dataFileContent;
                    } catch (ParserException ex) {
                        throw new RuntimeException(String.format("Failed to parse data file \"%s\".",
                                relativePath), ex);
                    } catch (Exception ex) {
                        throw new RuntimeException(String.format("Failed to get data file \"%s\".",
                                relativePath), ex);
                    }
                }
            }
        });

        // $macroArgs
        this.scriptEngine.put("$macroArgs", new Function<String, Object>() {
            @Override
            public Object apply(String argName) {
                if (actor.macroArgs != null) {
                    return actor.macroArgs.get(argName);
                } else {
                    return null;
                }
            }
        });

        // $out
        this.scriptEngine.put("$readOutput", new Function<String, Object>() {
            @Override
            public Object apply(String valueName) {
                if (actor.currentAction != null) {
                    if (actor.currentAction.hasOutput(valueName)) {
                        return actor.currentAction.readOutputValue(valueName);
                    } else {
                        throw new RuntimeException(String.format("Output value \"%s\" was not found for action %s",
                                valueName,
                                actor.currentAction.getClass().getName()));
                    }
                } else {
                    // This exception should never happen, unless we have a bug
                    throw new RuntimeException("The \"currentAction\" field was not populated for the test actor. This is probably a bug. Please send the log file and all other relevant information to the dev team for investigation");
                }
            }
        });

        // $require
        this.scriptEngine.put("$require", new Function<String, Object>() {
            @Override
            public Object apply(String relativePath) {
                // TODO: Continue implementation

                return null;
            }
        });

        // $runAction
        this.scriptEngine.put("$runAction", new BiFunction<String, Object, Object>() {
            @Override
            public Object apply(String className, Object args) {
                Map<String, Object> argsMap = (Map<String, Object>) args;
                try {
                    return executeAction(className, argsMap);
                } catch (Exception ex) {
                    String actionArguments;
                    if (argsMap.size() > 0) {
                        Gson gson = new Gson();
                        actionArguments = gson.toJson(argsMap);
                    } else {
                        actionArguments = "(no arguments provided)";
                    }

                    throw new RuntimeException(String.format(
                            "Failed executing action %s with arguments %s",
                            className,
                            actionArguments), ex);
                }
            }
        });

        this.scriptEngine.put("$sharedData", new TestActor.SharedDataFunction());
    }

    private void publishSharedData(Map<String, Object> sharedData) throws IOException {
        HttpRequest request = new HttpRequest(
                String.format("%s/api/session/%s/test/%s/data",
                        syncServiceBaseUrl,
                        this.currentTestSession.id,
                        this.currentTestSession.currentTestIndex),
                HttpVerb.PUT);

        Gson gson = new GsonBuilder().create();
        String jsonData = gson.toJson(sharedData);
        request.setContent(jsonData, ContentType.APPLICATION_JSON);

        Logger.debug(String.format("Publishing shared data: %s", jsonData));
        request.execute();
    }

    private void publishSharedData(String name, Object value) throws IOException {
        Map<String, Object> sharedData = new HashMap<String, Object>();
        sharedData.put(name, value);
        publishSharedData(sharedData);
    }

    /**
     * Waits for the actor to be acquired by a test session and does the work
     * for that one session, then returns.
     *
     * @param maxWaitTime Maximum time this test actor will wait to be acquired
     * by a test session
     * @throws Exception
     */
    @Override
    public void runOneSession(Duration maxWaitTime) throws Exception {
        Duration waitTime = Duration.ofSeconds(0);

//        Package thisPackage = this.getClass().getPackage();
//        File jarFile = new File(TestActor.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath());
//        
//        Logger.debug(String.format("JAR manifest info for %s [Implementation-Version = %s, Built-By: %s]",
//                thisPackage.getSpecificationTitle(),
//                thisPackage.getImplementationVersion(),
//                thisPackage.getSpe
//                ));
        if (this.currentTestSession == null) {
            log.info(String.format("Actor %s of type %s is waiting to be acquired by a test session%s...",
                    actorId,
                    actorType,
                    maxWaitTime != null
                            ? String.format(" (timeout is %s seconds)", maxWaitTime.getSeconds())
                            : ""));
        }

        // Wait until this actor is acquired by a test session. The testSessionId
        // field is populated in the announce thread.
        while (this.currentTestSession == null) {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
            }

            waitTime = waitTime.plus(Duration.ofMillis(1000));
            if (maxWaitTime != null && waitTime.compareTo(maxWaitTime) > 0) {
                log.info(String.format("The maximum wait time of %s seconds was exceeded while waiting for a test session to start",
                        maxWaitTime.getSeconds()));
                return;
            }
        }

        // Reset data file cache
        this.dataFileCache = new HashMap<>();

        HashMap<String, String> actorLogContext = new HashMap<String, String>();
        actorLogContext.put("actorId", actorId);
        actorLogContext.put("actorType", actorType);
        HttpLogger logger = new HttpLogger(syncServiceBaseUrl, this.currentTestSession.id, actorLogContext);
        this.log = logger;
        logger.setLevel(LogLevel.valueOf(config.getProperty("logLevel", "DEBUG")));

        this.log.info(String.format("Actor %s of type %s was acquired by test session %s",
                this.actorId,
                this.actorType,
                this.currentTestSession.id));

        Logger.setLogger(this.log);

        String scriptsDirFullPath = getScriptssDirFullPath();

        initializeScriptEngine();

        // Load JS scripts
        Path libsInitScriptPath = Paths.get(scriptsDirFullPath, "index.js");
        if (Files.exists(libsInitScriptPath)) {
            evalScriptFile(libsInitScriptPath.toString());
        }

        this.macroCache = new HashMap<>();

        // Start querying the session status and executing the tests
        while (this.currentTestSession != null) {
            SessionStatusResponse sessionStatus = getTestSessionStatus();

            // TODO: If the session status returns null for a longer time, abandon session
            if (sessionStatus != null) {
                if (sessionStatus.status.equals("started")) {
                    // Update the iteration number and reset current test, if necessary
                    if (this.currentTestSession.currentIteration < sessionStatus.currentIteration) {
                        this.currentTestSession.currentIteration = sessionStatus.currentIteration;
                        this.currentTestSession.currentTestIndex = -1;
                        this.currentTestSession.currentStepIndex = -1;
                        this.currentStepIsCompleted = false;
                    }

                    // Update the index of the current test for this actor and
                    // load the test definition
                    if (this.currentTestSession.currentTestIndex < sessionStatus.currentTestIndex) {
                        currentTest = null;
                        this.currentTestSession.currentTestIndex = sessionStatus.currentTestIndex;
                        this.currentTestSession.currentTestPath = sessionStatus.currentTestPath;
                        this.currentTestSession.currentTestName = sessionStatus.currentTestName;
                        this.currentTestSession.currentStepIndex = -1;

                        log.info("--------------------------------------------------");
                        log.info(String.format("Actor %s started executing test %s/%s...",
                                this.actorType,
                                this.currentTestSession.currentTestPath,
                                this.currentTestSession.currentTestName));

                        // Identify and parse the test definition file
                        try {
                            this.currentTest = getTestDefinition(String.format("%s/%s",
                                    this.currentTestSession.currentTestPath,
                                    this.currentTestSession.currentTestName));
                            this.scriptEngine.put("$test", currentTest);
                        } catch (Exception ex) {
                            StringWriter sw = new StringWriter();
                            ex.printStackTrace(new PrintWriter(sw));
                            log.error((sw.toString()));

                            // Notify the sync service that step 0 of the test failed
                            HttpRequest stepStatusRequest = new HttpRequest(
                                    String.format("%s/api/session/%s/actor/%s/test/%s/step/%s",
                                            syncServiceBaseUrl,
                                            this.currentTestSession.id,
                                            actorId,
                                            this.currentTestSession.currentTestIndex,
                                            0),
                                    HttpVerb.PUT);

                            // Start step 0
                            stepStatusRequest.setContent("{\"status\":\"started\",\"result\":\"pending\"}", ContentType.APPLICATION_JSON);
                            stepStatusRequest.execute();

                            // Fail step 0
                            stepStatusRequest.setContent("{\"status\":\"completed\",\"result\":\"failed\"}", ContentType.APPLICATION_JSON);
                            stepStatusRequest.execute();
                        }
                    }

                    if (this.currentTestSession.currentTestIndex == sessionStatus.currentTestIndex) {
                        // Update the current step index for the actor
                        if (this.currentTestSession.currentStepIndex < sessionStatus.currentStepIndex) {
                            this.currentTestSession.currentStepIndex = sessionStatus.currentStepIndex;
                            currentStepIsCompleted = false;
                        }

                        if (!currentStepIsCompleted && this.currentTestSession.currentStepIndex == sessionStatus.currentStepIndex) {
                            currentStepIsCompleted = true;
                            try {
                                executeTestStep(sessionStatus.currentStepIndex);
                            } catch (Exception ex) {
                                Logger.error(ex);
                            }
                        }
                    }
                } else if (sessionStatus.status.equals("completed")) {
                    this.currentTestSession = null;
                    log.info(String.format("Test session %s has completed\n", this.currentTestSession.id));
                }
            }

            try {
                Thread.sleep(1000);
            } catch (InterruptedException ex) {
            }
        }
    }

    @Override
    public void runOneSession() throws Exception {
        runOneSession(null);
    }

    private void startAnnounceThread() {
        stopAnnounceThread();

        announceThread = new Thread() {
            public void run() {
                while (!actorIsStopping) {
                    announce();
                    try {
                        Thread.sleep(5000);
                    } catch (InterruptedException ex) {
                        break;
                    }
                }
            }
        };

        log.info(String.format("Connecting to sync service at %s...", syncServiceBaseUrl));
        announceThread.start();
    }

    private void stopAnnounceThread() {
        if (announceThread != null) {
            announceThread.interrupt();
        }
    }
}
