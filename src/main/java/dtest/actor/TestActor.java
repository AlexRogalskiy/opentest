package dtest.actor;

import com.google.gson.*;
import dtest.actor.yaml.SkipNullRepresenter;
import dtest.base.TestAction;
import dtest.base.TestSession;
import dtest.base.contracts.ILogger;
import dtest.base.contracts.ITestActor;
import dtest.base.exceptions.ParameterNotFoundException;
import dtest.base.http.ContentType;
import dtest.base.http.HttpRequest;
import dtest.base.http.HttpVerb;
import dtest.base.logging.ConsoleLogger;
import dtest.base.logging.HttpLogger;
import dtest.base.logging.LogLevel;
import dtest.base.logging.Logger;
import dtest.base.testdef.MacroDefinition;
import dtest.base.testdef.TestDefAction;
import dtest.base.testdef.TestDefActor;
import dtest.base.testdef.TestDefStep;
import dtest.base.testdef.TestDefinition;
import dtest.base.util.Configuration;
import dtest.base.util.JarUtil;
import dtest.base.util.MainUtil;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.Field;
import java.math.BigInteger;
import java.net.URLEncoder;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.SecureRandom;
import java.time.Duration;
import java.util.*;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.jar.JarFile;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;
import jdk.nashorn.api.scripting.AbstractJSObject;
import jdk.nashorn.internal.runtime.Undefined;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;
import org.yaml.snakeyaml.DumperOptions;
import org.yaml.snakeyaml.Yaml;
import org.yaml.snakeyaml.nodes.Tag;
import org.yaml.snakeyaml.parser.ParserException;

/**
 * Implements the core functionality for a test actor type: reads the
 * configuration from a properties file, announces the actorType to the sync
 * service, then identifies, parses and executes the tests, as orchestrated by
 * the sync service.
 */
public class TestActor implements ITestActor {

    /**
     * The string identifier of the actorType.
     */
    private String actorId;

    /**
     * Identifies the type of actorType (GMA, NP6, etc.).
     */
    private final String actorType;

    private long announceCount = 0;

    private Thread announceThread;

    /**
     * Flags all threads and activities to shut down.
     */
    private boolean actorIsStopping;

    private Properties config;

    /**
     * The test action instance that is currently being executed, or null.
     */
    private TestAction currentAction;

    /**
     * Stores information about the test action currently executing. This info
     * is passed to the sync service when a test step ends to be used for
     * reporting purposes.
     */
    private TestActionInfo currentActionInfo;

    /**
     * Stores the name of the currently executing macro, if any, or null
     * otherwise.
     */
    private String currentMacro;

    private String currentScript;

    /**
     * Stores information about the test actions in the current test step. This
     * info is passed to the sync service to be used for reporting purposes.
     */
    private List<TestActionInfo> currentStepActions;

    private int currentStepIndex;

    private boolean currentStepIsCompleted;

    private TestDefinition currentTest;

    /**
     * Stores information about the current test session, if any. If not null,
     * it means that this test actorType was acquired by the sync service and
     * allocated to a particular test session
     */
    private TestSession currentTestSession;

    /**
     * Caches the content of data files used in the tests, as soon as a test
     * first reads a value from a data file. The cache is reset at the beginning
     * of each test session.
     */
    private Map<String, Object> dataFileCache;

    private ILogger log;

    /**
     * The arguments for the current macro action being executed (if any).
     */
    private Map<String, Object> macroArgs;

    /**
     * Caches macro definitions so we don't have to load them from disk every
     * time they're used.
     */
    private Map<String, MacroDefinition> macroCache;

    private ScriptEngine scriptEngine;

    private final String syncServiceBaseUrl;

    private final String testRepoDirName;

    private String testRepoLocation;

    public TestActor() {
        this(null);
    }

    public TestActor(Map<Object, Object> configOverrides) {
        ConsoleLogger consoleLogger = new ConsoleLogger();
        this.log = consoleLogger;
        this.log.info("");

        Logger.setLogger(this.log);

        try {
            this.config = Configuration.getConfiguration("actor.properties");
        } catch (Exception ex) {
            // Also support TestActor.properties file name, just in case
            this.config = Configuration.getConfiguration("TestActor.properties");
        }

        if (configOverrides != null) {
            this.config.putAll(configOverrides);
        }

        consoleLogger.setLevel(LogLevel.valueOf(config.getProperty("logLevel", "DEBUG")));

        logJarVersions();

        try {
            // The configuration is loaded from the main JAR file's resources, so
            // we are logging the main class name so we can troubleshoot later
            Class<?> mainClass = MainUtil.getMainClass();
            Logger.trace(String.format("The main class is %s", mainClass.getName()));
        } catch (Exception ex) {
        }

        Thread.currentThread().setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
            @Override
            public void uncaughtException(Thread t, Throwable e) {
                Logger.error(e);
            }
        });

        this.actorId = getStringParameter("actorId", "");
        this.actorType = getStringParameter("actorType");
        this.syncServiceBaseUrl = getStringParameter("syncServiceBaseUrl").replaceAll("^[\\s]+|[/\\s]+$", "");

        this.testRepoDirName = getStringParameter("testRepoDirName", "").replaceAll("^[\\\\/\\s]+|[\\\\\\/\\s]+$", "");
        this.testRepoLocation = getStringParameter("testRepoLocation", "");
        this.testRepoLocation = this.testRepoLocation.replaceAll("^[\\s]+|[\\\\\\/\\s]+$", "");

//        if (!new File(testRepoLocation).exists()) {
//            throw new RuntimeException("The test repository directory could not be found. You can use the testRepoLocation parameter to configure it.");
//        }
        if (this.actorId == null || this.actorId.isEmpty()) {
            SecureRandom random = new SecureRandom();
            this.actorId = new BigInteger(16, random).toString(10);
        }
        this.actorIsStopping = false;
        this.currentTestSession = null;

        startAnnounceThread();
    }

    private void abandonSession() {
        this.currentTestSession = null;
    }

    /**
     * Announces the actorType to the sync service, so it can be used for
     * running a test session.
     */
    private void announce() {
        ++this.announceCount;

        try {
            HttpRequest request = new HttpRequest(syncServiceBaseUrl + "/api/actor/announce", HttpVerb.POST);
            request.setContent(String.format("{\"actorId\":\"%s\",\"actorType\":\"%s\"}", actorId, actorType), ContentType.APPLICATION_JSON);
            request.execute();

            int statusCode = request.getResponseStatusCode();
            if (statusCode != 200) {
                throw new RuntimeException(String.format("Failed to announce actor %s%s to the sync service. The HTTP request was %s %s. The response status code was %s.",
                        this.actorType,
                        this.actorId != null ? String.format("(%s)", this.actorId) : "",
                        request.getHttpVerb(),
                        request.getUri(),
                        statusCode));
            }

            String response = request.getResponseAsString();
            JsonElement jelement = new JsonParser().parse(response);
            JsonElement testSessionIdElem = jelement.getAsJsonObject().get("testSessionId");

            if (testSessionIdElem != null && !testSessionIdElem.isJsonNull()) {
                String testSessionId = testSessionIdElem.getAsString();
                String currentSessionId = this.currentTestSession != null
                        ? this.currentTestSession.id
                        : null;

                if (this.currentTestSession == null || !testSessionId.equals(currentSessionId)) {
                    Logger.trace("Initializing test session information in the \"announce\" method...");
                    Logger.trace(String.format("Session ID in sync server response was %s; actor session ID was %s",
                            testSessionId,
                            currentSessionId));
                    this.currentTestSession = new TestSession(testSessionId);
                }
            } else {
                this.currentTestSession = null;
            }
        } catch (Exception ex) {
            ex.printStackTrace();

            try {
                Thread.sleep(10000);
            } catch (InterruptedException ex1) {
            }
        }
    }

    /**
     * Sets a flag that signals all threads and activities for this actorType to
     * shut down.
     */
    @Override
    public void close() {
        actorIsStopping = true;
    }

    /**
     * Initialize the JavaScript interpreter that will be used to evaluate
     * action arguments and run "script" test actions.
     */
    private ScriptEngine createScriptEngine() {
        ScriptEngine engine = new ScriptEngineManager().getEngineByName("nashorn");

        try {
            InputStream inputStream;
            
            inputStream = this.getClass().getResourceAsStream("/js/helpers.js");
            engine.eval(new InputStreamReader(inputStream));
            
            inputStream = this.getClass().getResourceAsStream("/js/external/almond.js");
            engine.eval(new InputStreamReader(inputStream));
            
            inputStream = this.getClass().getResourceAsStream("/js/loadAmdModuleAs.js");
            String loadAmdModuleAs = IOUtils.toString(inputStream, Charset.forName("UTF-8"));
            
            inputStream = this.getClass().getResourceAsStream("/js/external/deep-diff.js");
            String moduleDeepDiff = IOUtils.toString(inputStream, Charset.forName("UTF-8"));
            engine.eval(loadAmdModuleAs
                    .replace("$MODULE_NAME", "deep-diff")
                    .replace("$MODULE_SOURCE", moduleDeepDiff));
            
            inputStream = this.getClass().getResourceAsStream("/js/createGlobals.js");
            engine.eval(new InputStreamReader(inputStream));
        } catch (Exception ex) {
            throw new RuntimeException("Failed to evaluate JS code while preparing the JS interpreter", ex);
        }

        // Keeping a final reference to the current actorType instance, so that we
        // can access it from anonymous classes below
        final TestActor actor = this;

        // $data
        engine.put("$data", new Function<String, Object>() {
            @Override
            public Object apply(String relativePath) {
                if (dataFileCache.containsKey(relativePath)) {
                    return dataFileCache.get(relativePath);
                } else {
                    InputStream dataFileStream;
                    try {
                        dataFileStream = getTestAsset("data", relativePath);
                    } catch (Exception ex) {
                        throw new RuntimeException(String.format("Failed to get data file \"%s\".",
                                relativePath), ex);
                    }

                    Object dataFileContent;
                    try {
                        Yaml yaml = new Yaml();
                        dataFileContent = yaml.load(dataFileStream);
                    } catch (ParserException ex) {
                        throw new RuntimeException(String.format("Failed to parse data file \"%s\".",
                                relativePath), ex);
                    }

                    try {
                        dataFileCache.put(relativePath, dataFileContent);
                        dataFileContent = evalObject(dataFileContent);
                        return dataFileContent;
                    } catch (Exception ex) {
                        throw new RuntimeException(String.format("Failed to evaluate data file \"%s\".",
                                relativePath), ex);
                    }
                }
            }
        });

        // $eval
        engine.put("$eval", new Function<Object, Object>() {
            @Override
            public Object apply(Object expression) {
                return evalObject(expression);
            }
        });

        // $json
        engine.put("$json", new Function<Object, Object>() {
            @Override
            public Object apply(Object value) {
                actor.scriptEngine.put("$scriptObjectToSerialize", value);
                String scriptObjJson;

                try {
                    scriptObjJson = actor.scriptEngine.eval("JSON.stringify($scriptObjectToSerialize)").toString();
                } catch (Exception ex) {
                    throw new RuntimeException(String.format("Failed to convert value to JSON. The value was %s", value));
                }

                return scriptObjJson;
            }
        });

        // $macroArgs
        engine.put("$macroArgs", new Function<String, Object>() {
            @Override
            public Object apply(String argName) {
                if (actor.macroArgs != null) {
                    return actor.macroArgs.get(argName);
                } else {
                    return null;
                }
            }
        });

        // $readOutput
        engine.put("$readOutput", new Function<String, Object>() {
            @Override
            public Object apply(String valueName) {
                if (actor.currentAction != null) {
                    if (actor.currentAction.hasOutput(valueName)) {
                        return actor.currentAction.readOutputValue(valueName);
                    } else {
                        throw new RuntimeException(String.format("Output value \"%s\" was not found for action %s",
                                valueName,
                                actor.currentAction.getClass().getName()));
                    }
                } else {
                    throw new RuntimeException("The \"currentAction\" field was not populated for the test actor. This exception can happen if you are trying to read test action output using the \"$readOutput\" function before the action was executed. If you think thins is not the case, please report this to the dev team (send the log file and information on how to reproduce).");
                }
            }
        });

        // $require
        engine.put("$require", new Function<String, Object>() {
            @Override
            public Object apply(String relativePath) {
                // TODO: Continue implementation

                return null;
            }
        });

        // $runAction
        engine.put("$runAction", new BiFunction<String, Object, Object>() {
            @Override
            public Object apply(String className, Object args) {
                Map<String, Object> argsMap = (Map<String, Object>) args;
                try {
                    return executeAction(className, argsMap);
                } catch (Exception ex) {
                    String actionArguments;
                    if (argsMap.size() > 0) {
                        Gson gson = new Gson();
                        actionArguments = gson.toJson(argsMap);
                    } else {
                        actionArguments = "(no arguments provided)";
                    }

                    throw new RuntimeException(String.format(
                            "Failed executing action %s with arguments %s",
                            className,
                            actionArguments), ex);
                }
            }
        });

        engine.put("$sharedData", new TestActor.SharedDataFunction());

        return engine;
    }

    /**
     * Evaluate an object as JavaScript (if applicable) and return the evaluated
     * value. In the case of maps or arrays, we evaluate each one of their
     * element's values recursively.
     *
     * @param objValue
     * @return
     */
    private Object evalObject(Object objValue) {
        if (objValue == null) {
            return null;
        }

        if (objValue instanceof Map) {
            Map<String, Object> mapValue = (Map) objValue;
            for (Map.Entry<String, Object> entry : mapValue.entrySet()) {
                try {
                    Object result = evalObject(entry.getValue());
                    mapValue.put(entry.getKey(), result);
                } catch (Exception ex) {
                    throw new RuntimeException(String.format(
                            "There was an error while evaluating property \"%s\"",
                            entry.getKey()), ex);
                }
            }
            return mapValue;
        } else if (objValue instanceof ArrayList) {
            // Evaluate all elements of the array
            ArrayList arrayValue = (ArrayList) objValue;
            for (int index = 0; index < arrayValue.size(); ++index) {
                arrayValue.set(index, evalObject(arrayValue.get(index)));
            }
            return arrayValue;
        } else if (objValue instanceof String) {
            Object returnValue = (String) objValue;
            boolean evaluationFinished = false;
            int iterationCount = 0;
            Object evalResult;

            // Evaluate the JS expression, then evaluate the result of the
            // evaluation, until we no longer have a JS expression, but only
            // an ordinary string
            while (!evaluationFinished) {
                ++iterationCount;

                if (iterationCount >= 100) {
                    throw new RuntimeException(String.format(
                            "We iterated %s times while evaluating a JavaScript data property. We are giving up, since there is likely a circular dependency between data properties.",
                            iterationCount));
                }

                try {
                    if (returnValue instanceof String) {
                        evalResult = evalString((String) returnValue);
                    } else {
                        evalResult = evalObject(returnValue);
                    }
                } catch (StackOverflowError e) {
                    throw new RuntimeException(String.format(
                            "We got a StackOverflowError while evaluating a data property. The property's value was \"%s\". This is typically caused by a circular dependency (e.g. property1 refercencing property2, which, in turn, references property1).",
                            objValue
                    ));
                }

                if (evalResult == returnValue) {
                    evaluationFinished = true;
                }

                returnValue = evalResult;
            }

            return returnValue;
        } else {
            return objValue;
        }
    }

    /**
     * Determines whether a string value is a script and returns the interpreted
     * value of that string if it is, or the plain string value otherwise.
     */
    private Object evalString(String expression) {
        // A string is considered to be a JS expression if it start with $script or one of the $ functions
        if (expression.matches("(?s)^[\\s\\n]*(\\$data|\\$dataRecord|\\$format|\\$eval|\\$json|\\$script|\\$macroArgs|\\$sharedData|\\$readOutput).*")) {
            // Remove the $script syntax from the beggining of the string
            String cleanedExpression = expression.replaceAll("^\\s*\\$script\\s*", "");

            try {
                return scriptEngine.eval(cleanedExpression);
            } catch (ScriptException ex) {
                throw new RuntimeException(String.format(
                        "An error was encountered while executing a script. The script content was: %s",
                        cleanedExpression), ex);
            }
        } else {
            // This is not JS code, so we just return the original string
            return expression;
        }
    }

    private Object evalScriptFile(String scriptFileFullPath) throws ScriptException, FileNotFoundException {
        Path scriptPath = Paths.get(scriptFileFullPath);

        if (Files.exists(scriptPath)) {
            this.currentScript = scriptPath.toString();
        }

        return this.scriptEngine.eval(new FileReader(scriptPath.toString()));
    }

    /**
     * Executes an action and returns the output values produced by the action.
     */
    private Map<String, Object> executeAction(String actionClassName, Map<String, Object> args) throws Exception {
        if (args.containsKey("executeIf") && args.get("executeIf") != Boolean.TRUE) {
            Logger.debug(String.format("Skipping conditional action %s", actionClassName));
            return new HashMap<>();
        }

        try {
            Class actionClass;
            actionClass = Class.forName(actionClassName);

            if (TestAction.class.isAssignableFrom(actionClass)) {
                TestAction actionInstance = (TestAction) actionClass.newInstance();
                actionInstance.setSession(new TestSession(this.currentTestSession));
                this.currentAction = actionInstance;

                // Inject the logger instance into the action
                Field[] fields = TestAction.class.getDeclaredFields();
                for (Field f : fields) {
                    if (f.getType().isAssignableFrom(ILogger.class)) {
                        f.setAccessible(true);
                        f.set(actionInstance, this.log);
                        f.setAccessible(false);
                    }
                }

                if (args != null) {
                    for (Map.Entry<String, Object> entry : args.entrySet()) {
                        actionInstance.writeArgument(entry.getKey(), entry.getValue());
                    }
                }

                actionInstance.initialize();

                try {
                    Logger.trace(String.format("Executing action %s with arguments %s...",
                            actionClass.getName(),
                            actionInstance.getArgs()));
                    actionInstance.run();
                } catch (Exception ex) {
                    if (actionInstance.isOptional()) {
                        Logger.debug(String.format(
                                "Optional action %s failed. Execution will continue.",
                                actionInstance.getClass().getName()));
                    } else {
                        throw ex;
                    }
                }

                return actionInstance.getOutput();
            } else {
                throw new RuntimeException(String.format("Class %s is not a test action class and cannot be used in test definitions",
                        actionClassName));
            }
        } catch (ClassNotFoundException | NoClassDefFoundError ex) {
            throw new RuntimeException(String.format(
                    "Failed to find test action class \"%s\". Most common causes to watch for are capitalization mistakes (e.g. using \"some.package.sampleAction\" instead \"some.package.SampleAction\") or spelling mistakes. If these look good, make sure the JAR file where the test action class is implemented exists in the CLASSPATH.",
                    actionClassName), ex);
        } catch (InstantiationException | IllegalAccessException ex) {
            throw new RuntimeException(String.format(
                    "Failed to instantiate action class \"%s\"",
                    actionClassName), ex);
        }
    }

    /**
     * Executes an action and returns the output values produced by the action.
     */
    private Map<String, Object> executeAction(TestDefAction actionDef) {
        long startTimeNano = System.nanoTime();
        TestActionInfo localActionInfo = new TestActionInfo();
        localActionInfo.actorType = this.actorType;
        localActionInfo.macro = this.currentMacro;
        localActionInfo.result = null;
        localActionInfo.step = this.currentStepIndex;

        try {
            // Added for backward compatibility and will be removed eventually
            if (actionDef.action == null) {
                actionDef.action = actionDef.type;
                actionDef.type = null;
            }

            Map<String, Object> actionArgs = (Map) evalObject(actionDef.args);
            if (actionArgs == null) {
                actionArgs = new HashMap<String, Object>();
            }
            localActionInfo.args = actionArgs;

            if (actionArgs.containsKey("executeIf") && actionArgs.get("executeIf") != Boolean.TRUE) {
                String actionType = actionDef.action != null
                    ? actionDef.action
                    : actionDef.macro != null
                            ? actionDef.macro
                            : actionDef.script != null ? "of type \"script\"" : "(unknown)";
                Logger.debug(String.format("Skipping conditional action %s", actionType));
                return new HashMap<>();
            }

            Map<String, Object> outputValues = null;

            // The currentActionInfo member is used is other methods to get
            // access to the action info object
            this.currentActionInfo = localActionInfo;

            if (actionDef.script != null) {
                // SCRIPT ACTION
                localActionInfo.action = ScriptAction.class.getName();
                actionDef.action = ScriptAction.class.getName();

                try {
                    scriptEngine.eval(actionDef.script);
                } catch (ScriptException ex) {
                    throw new RuntimeException(String.format(
                            "There was an error executing a script while processing a script action. The script content was: %s",
                            actionDef.script), ex);
                }
            } else if (actionDef.macro != null) {
                // MACRO ACTION
                this.currentMacro = actionDef.macro;
                localActionInfo.action = MacroAction.class.getName();
                actionDef.action = MacroAction.class.getName();
                try {
                    String macroPartialPath = actionDef.macro.replaceAll("[\\.\\\\]", "/");
                    MacroDefinition macroDef = getMacroDefinition(macroPartialPath);
                    macroDef.fullName = actionDef.macro;
                    outputValues = executeMacroAction(macroDef, actionArgs);
                } catch (Exception ex) {
                    throw new Exception(String.format("There was an error executing macro action %s",
                            actionDef.macro), ex);
                } finally {
                    this.currentMacro = null;
                }
            } else if (actionDef.action != null) {
                // REGULAR ACTION
                localActionInfo.action = actionDef.action;
                outputValues = executeAction(actionDef.action, actionArgs);
            }

            // Evaluate and publish values in the test's shared data
            if (actionDef.sharedData != null) {
                Map<String, Object> sharedData = new HashMap<String, Object>();

                for (Map.Entry<String, Object> entry : actionDef.sharedData.entrySet()) {
                    sharedData.put(entry.getKey(), this.evalObject(entry.getValue()));
                }

                publishSharedData(sharedData);
            }

            if (outputValues == null) {
                outputValues = new HashMap<String, Object>();
            }

            long endTimeNano = System.nanoTime();
            localActionInfo.duration = (int) ((endTimeNano - startTimeNano) / 1000000000.0);
            localActionInfo.result = "passed";

            return outputValues;
        } catch (Exception ex) {
            localActionInfo.result = "failed";

            String actionType = actionDef.action != null
                    ? actionDef.action
                    : actionDef.macro != null
                            ? actionDef.macro
                            : actionDef.script != null ? "of type \"script\"" : "?";

            String actionArguments;
            if (this.currentAction != null) {
                String[] argNames = this.currentAction.getArgNames();
                if (argNames.length > 0) {
                    actionArguments = this.currentAction.getArgs().toString();
                } else {
                    actionArguments = "(no arguments provided)";
                }
            } else {
                actionArguments = "N/A (current action instance was null)";
            }

            throw new RuntimeException(String.format(
                    "Failed executing action %s with arguments %s",
                    actionType,
                    actionArguments), ex);
        } finally {
            localActionInfo.description
                    = (actionDef.description != null && !actionDef.description.isEmpty())
                            ? actionDef.description
                            : actionDef.action;
            this.currentStepActions.add(localActionInfo);
            this.currentActionInfo = null;
        }
    }

    private Map<String, Object> executeMacroAction(MacroDefinition macroDef, Map<String, Object> macroArgs) throws Exception {
        this.macroArgs = macroArgs;

        Logger.trace(String.format("Executing macro %s with arguments %s...",
                macroDef.fullName,
                macroArgs));

        // Execute the actions for the current macro, in the order
        // they appear in the macro definition file
        if (macroDef.actions != null) {
            for (TestDefAction actionDef : macroDef.actions) {
                try {
                    log.debug(String.format("Executing action %s/%s of macro %s%s...",
                            macroDef.actions.indexOf(actionDef),
                            macroDef.actions.size(),
                            macroDef.fullName,
                            actionDef.description != null
                                    ? String.format(" (%s)", actionDef.description)
                                    : ""));
                    executeAction(actionDef);
                } catch (Exception ex) {
                    final DumperOptions options = new DumperOptions();
                    options.setDefaultFlowStyle(DumperOptions.FlowStyle.FLOW);
                    options.setPrettyFlow(true);

                    SkipNullRepresenter representer = new SkipNullRepresenter();
                    representer.addClassTag(TestDefAction.class, Tag.MAP);

                    Yaml yaml = new Yaml(representer, options);
                    String actionDefYaml = yaml.dump(actionDef);

                    throw new RuntimeException(String.format(
                            "There was an error while executing action \"%s\" (with index %s) in macro %s.\nThe action definition was:\n%s",
                            actionDef.action,
                            macroDef.actions.indexOf(actionDef),
                            macroDef.fullName,
                            actionDefYaml), ex);
                }
            }
        }

        // TODO: Return the actual macro output values
        return null;
    }

    private void executeTestStep(int stepIndex) throws Exception {
        this.currentStepIndex = stepIndex;

        // Notify the sync service that the step execution is starting
        HttpRequest stepStatusRequest = new HttpRequest(
                String.format("%s/api/session/%s/actor/%s/test/%s/step/%s",
                        syncServiceBaseUrl,
                        this.currentTestSession.id,
                        actorId,
                        this.currentTestSession.currentTestIndex,
                        stepIndex),
                HttpVerb.PUT);
        stepStatusRequest.setContent("{\"status\":\"started\",\"result\":\"pending\"}", ContentType.APPLICATION_JSON);
        stepStatusRequest.execute();

        this.currentStepActions = new ArrayList<TestActionInfo>();

        try {
            // Identify the actorType node in the test definition data
            Optional<TestDefActor> testDefActorOpt = currentTest.actors.stream()
                    .filter(a -> a.actorType.equals(this.actorType)).findFirst();
            if (testDefActorOpt.isPresent()) {
                Optional<TestDefStep> testDefStepOpt = testDefActorOpt.get().steps.stream()
                        .filter(s -> s.step == stepIndex).findFirst();
                if (testDefStepOpt.isPresent() && (testDefStepOpt.get().actions != null)) {
                    log.info(String.format("Executing step %s of test %s/%s...",
                            stepIndex,
                            this.currentTestSession.currentTestPath,
                            this.currentTestSession.currentTestName));

                    // Execute the actions for the current step, in the order
                    // they appear in the test definition file
                    List<TestDefAction> stepActions = testDefStepOpt.get().actions;
                    for (TestDefAction actionDef : stepActions) {
                        try {
                            log.info(String.format("Executing action %s of step %s%s...",
                                    stepActions.indexOf(actionDef),
                                    stepIndex,
                                    actionDef.description != null
                                            ? String.format(" (%s)", actionDef.description)
                                            : ""));
                            executeAction(actionDef);
                        } catch (Exception ex) {
                            if (this.currentAction != null) {
                                this.takeScreenShot();
                            }

                            String actionName = actionDef.action != null
                                    ? actionDef.action
                                    : actionDef.macro != null
                                            ? actionDef.macro
                                            : actionDef.script != null ? "of type script" : "?";

                            final DumperOptions options = new DumperOptions();
                            options.setDefaultFlowStyle(DumperOptions.FlowStyle.FLOW);
                            options.setPrettyFlow(true);

                            SkipNullRepresenter representer = new SkipNullRepresenter();
                            representer.addClassTag(TestDefAction.class, Tag.MAP);

                            Yaml yaml = new Yaml(representer, options);
                            String actionDefYaml = yaml.dump(actionDef);

                            throw new RuntimeException(String.format(
                                    "There was an error while executing action %s (with index %s) in step %s of test %s/%s.\nThe action definition was:\n%s",
                                    actionName,
                                    testDefStepOpt.get().actions.indexOf(actionDef),
                                    stepIndex,
                                    this.currentTestSession.currentTestPath,
                                    this.currentTestSession.currentTestName,
                                    actionDefYaml), ex);
                        }
                    } // for actionDef in stepActions
                }
            }

            // If the "takeScreenshot" config parameter is set to "ALWAYS", we also
            // take screenshots after successful test steps
            if (config.getProperty("takeScreenshot", "ON_FAILURE").equalsIgnoreCase("ALWAYS")) {
                this.takeScreenShot();
            }

            // Notify the sync service that the step execution was completed successfully
            Map<String, Object> content = new HashMap<String, Object>();
            content.put("actions", this.currentStepActions);
            content.put("status", "completed");
            content.put("result", "passed");

            Gson gson = new Gson();
            stepStatusRequest.setContent(gson.toJson(content), ContentType.APPLICATION_JSON);
            stepStatusRequest.execute();
        } catch (Exception ex) {
            // Notify the sync service that the step execution failed
            Map<String, Object> content = new HashMap<String, Object>();
            content.put("actions", this.currentStepActions);
            content.put("status", "completed");
            content.put("result", "failed");
            content.put("stackTrace", Logger.getStackTrace(ex));

            Gson gson = new Gson();
            stepStatusRequest.setContent(gson.toJson(content), ContentType.APPLICATION_JSON);
            stepStatusRequest.execute();

            Exception newException = new Exception(String.format("Failed executing test %s/%s, step %s",
                    this.currentTestSession.currentTestPath,
                    this.currentTestSession.currentTestName,
                    stepIndex), ex);
            throw newException;
        } finally {
            this.currentAction = null;
        }
    }

    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        close();
    }

    private String getDataDirFullPath() {
        // TODO: Read test-repo.yaml

        return Paths.get(testRepoLocation, testRepoDirName, "data").toString();
    }

    private String getMacroDirFullPath() {
        // TODO: Read test-repo.yaml

        String macroDirFullPath;
        File macroDirFile;

        // First look for the /macros directory
        macroDirFullPath = Paths.get(testRepoLocation, testRepoDirName, "macros").toString();
        macroDirFile = new File(macroDirFullPath);
        if (macroDirFile.exists()) {
            return macroDirFullPath;
        } else {
            // Then look for the /libs/macros directory
            macroDirFullPath = Paths.get(testRepoLocation, testRepoDirName, "libs", "macros").toString();
            macroDirFile = new File(macroDirFullPath);
            if (macroDirFile.exists()) {
                return macroDirFullPath;
            } else {
                // Finally just return the default macro path
                return Paths.get(testRepoLocation, testRepoDirName, "macros").toString();
            }
        }
    }

    private String getScriptssDirFullPath() {
        // TODO: Read test-repo.yaml
        return Paths.get(testRepoLocation, testRepoDirName, "libs", "scripts").toString();
    }

    private String getStringParameter(String parmeterName, String defaultValue) throws ParameterNotFoundException {
        String parameterValue = config.getProperty(parmeterName);
        if (parameterValue != null) {
            return parameterValue;
        } else if (defaultValue != null) {
            return defaultValue;
        } else {
            throw new ParameterNotFoundException(String.format("Parameter %s was not found", parmeterName));
        }
    }

    private String getStringParameter(String parmeterName) {
        return getStringParameter(parmeterName, null);
    }

    /**
     * Queries the sync service for the definition of the specified test asset
     * and returns an input stream with the content of that asset.
     */
    private InputStream getTestAsset(String assetType, String partialPath) {
        // URL-encode the partial path
        String urlEncodedPartialPath = null;
        try {
            urlEncodedPartialPath = URLEncoder.encode(partialPath, "UTF-8");
        } catch (UnsupportedEncodingException ex) {
            throw new RuntimeException(String.format("Failed encoding partial path %s",
                    partialPath), ex);
        }

        // Prepare HTTP request
        String url = String.format(syncServiceBaseUrl + "/api/test-asset?type=%s&path=%s",
                assetType,
                urlEncodedPartialPath);
        HttpRequest request = new HttpRequest(url, HttpVerb.GET);

        try {
            request.execute();
        } catch (Exception ex) {
            throw new RuntimeException(String.format(
                    "An error occured while making the HTTP request to get %s asset %s from the sync service",
                    assetType,
                    partialPath), ex);
        }

        if (request.getResponseStatusCode() == 200) {
            try {
                return request.getResponseAsStream();
            } catch (Exception ex) {
                throw new RuntimeException(String.format(
                        "An error occured while retrieving the HTTP response input stream for %s asset %s from the sync service",
                        assetType,
                        partialPath), ex);
            }
        } else {
            throw new RuntimeException(String.format("Failed to get %s asset %s from the sync service. The HTTP status code was: %s. The HTTP body was: %s",
                    assetType,
                    partialPath,
                    request.getResponseStatusCode(),
                    request.getResponseAsString()));
        }
    }

    public String getType() {
        return this.actorType;
    }

    private MacroDefinition getMacroDefinition(String partialPath) {
        Yaml yaml = new Yaml();
        MacroDefinition def = yaml.loadAs(getTestAsset("macro", partialPath), MacroDefinition.class);
        return def;
    }

    private TestDefinition getTestDefinition(String partialPath) {
        Yaml yaml = new Yaml();
        TestDefinition def = yaml.loadAs(getTestAsset("test", partialPath), TestDefinition.class);

        // Account for usage of obsolete "index" property in the step definition
        // and just transfer its value to the correct property - "step".
        for (TestDefActor actor : def.actors) {
            for (TestDefStep step : actor.steps) {
                if (step.step == null) {
                    step.step = step.index;
                }
            }
        }
        return def;
    }

    private String getTestsDirFullPath() {
        // TODO: Read test-repo.yaml
        return Paths.get(testRepoLocation, testRepoDirName, "tests").toString();
    }

    private SessionStatusResponse getTestSessionStatus() {
        try {
            HttpRequest request = new HttpRequest(
                    String.format("%s/api/session/%s/status",
                            syncServiceBaseUrl,
                            this.currentTestSession.id),
                    HttpVerb.GET);
            request.execute();
            int statusCode = request.getResponseStatusCode();

            if (statusCode < 300) {
                String responseString = request.getResponseAsString();
                if (responseString != null) {
                    JsonElement responseElement = new JsonParser().parse(responseString);
                    JsonObject responseObj = responseElement.getAsJsonObject();
                    SessionStatusResponse sessionStatus = new SessionStatusResponse();
                    sessionStatus.status = responseObj.get("status").getAsString();
                    if (sessionStatus.status.equals("started")) {
                        sessionStatus.currentTestIndex = responseObj.get("currentTestIndex").getAsInt();
                        sessionStatus.currentStepIndex = responseObj.get("currentStepIndex").getAsInt();
//                        sessionStatus.currentDataRecordIndex = responseObj.get("currentDataRecordIndex").getAsInt();
                        sessionStatus.currentIteration = responseObj.get("currentIteration").getAsInt();
                        sessionStatus.currentTestPath = responseObj.get("currentTestPath").getAsString();
                        sessionStatus.currentTestName = responseObj.get("currentTestName").getAsString();
                    }

                    return sessionStatus;
                }
            } else if (statusCode == 404) {
                // When we receive a 404, it means the session died
                abandonSession();
            }
        } catch (Exception ex) {
            throw new RuntimeException(String.format("Failed to get or parse status data for session %s",
                    this.currentTestSession.id), ex);
        }

        return null;
    }

    /**
     * Logs the names, versions and commit SHAs of relevant JAR files.
     */
    private void logJarVersions() {
        Collection<File> jarFiles = null;

        List<JarFile> jars = new LinkedList<>();
        JarFile mainJar = JarUtil.getJarFile(TestActor.class);
        if (mainJar != null) {
            jars.add(mainJar);
            File mainJarFile = new File(mainJar.getName());
            jarFiles = FileUtils.listFiles(mainJarFile.getParentFile(), new String[]{"jar"}, true);
        } else {
            jarFiles = FileUtils.listFiles(new File("."), new String[]{"jar"}, true);
        }

        if (jarFiles != null && jarFiles.size() > 0) {
            Logger.info("File versions:");

            for (File childFile : jarFiles) {
                if (childFile.getName().matches("dtest.+\\.jar")) {
                    try {
                        JarFile jar = new JarFile(childFile);
                        Logger.info(String.format("  %s: %s %s",
                                new File(jar.getName()).getName(),
                                JarUtil.getManifestAttribute(jar, "Build-Time"),
                                JarUtil.getManifestAttribute(jar, "Implementation-Version")));
                    } catch (IOException ex) {
                        Logger.warning(String.format("Failed to determine version for JAR %s",
                                childFile.getName()));
                    }
                }
            }

            Logger.info("");
        }
    }

    private void publishSharedData(Map<String, Object> sharedData) throws IOException {
        HttpRequest request = new HttpRequest(
                String.format("%s/api/session/%s/test/%s/data",
                        syncServiceBaseUrl,
                        this.currentTestSession.id,
                        this.currentTestSession.currentTestIndex),
                HttpVerb.PUT);

        Gson gson = new GsonBuilder().create();
        String jsonData = gson.toJson(sharedData);
        request.setContent(jsonData, ContentType.APPLICATION_JSON);

        Logger.debug(String.format("Publishing shared data: %s", jsonData));
        request.execute();
    }

    private void publishSharedData(String name, Object value) throws IOException {
        Map<String, Object> sharedData = new HashMap<String, Object>();
        sharedData.put(name, value);
        publishSharedData(sharedData);
    }

    /**
     * Waits for the actorType to be acquired by a test session and does the
     * work for that one session, then returns.
     *
     * @param maxWaitTime Maximum time this test actorType will wait to be
     * acquired by a test session
     * @throws Exception
     */
    @Override
    public void runOneSession(Duration maxWaitTime) throws Exception {
        Duration waitTime = Duration.ofSeconds(0);

//        Package thisPackage = this.getClass().getPackage();
//        File jarFile = new File(TestActor.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath());
//        
//        Logger.debug(String.format("JAR manifest info for %s [Implementation-Version = %s, Built-By: %s]",
//                thisPackage.getSpecificationTitle(),
//                thisPackage.getImplementationVersion(),
//                thisPackage.getSpe
//                ));
        if (this.currentTestSession == null) {
            log.info(String.format("Actor %s of type %s is waiting to be acquired by a test session%s...",
                    actorId,
                    actorType,
                    maxWaitTime != null
                            ? String.format(" (timeout is %s seconds)", maxWaitTime.getSeconds())
                            : ""));
        }

        // Wait until this actorType is acquired by a test session. The
        // currentTestSession field is populated in the announce thread which
        // is started in the constructor.
        while (this.currentTestSession == null) {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
            }

            waitTime = waitTime.plus(Duration.ofMillis(1000));
            if (maxWaitTime != null && waitTime.compareTo(maxWaitTime) > 0) {
                log.info(String.format("The maximum wait time of %s seconds was exceeded while waiting for a test session to start",
                        maxWaitTime.getSeconds()));
                return;
            }
        }

        // Reset data file and macro caches
        this.dataFileCache = new HashMap<>();
        this.macroCache = new HashMap<>();

        HashMap<String, String> actorLogContext = new HashMap<String, String>();
        actorLogContext.put("actorId", actorId);
        actorLogContext.put("actorType", actorType);
        HttpLogger logger = new HttpLogger(syncServiceBaseUrl, this.currentTestSession.id, actorLogContext);
        this.log = logger;
        logger.setLevel(LogLevel.valueOf(config.getProperty("logLevel", "DEBUG")));

        this.log.info(String.format("Actor %s of type %s was acquired by test session %s",
                this.actorId,
                this.actorType,
                this.currentTestSession.id));

        Logger.setLogger(this.log);

        logJarVersions();

        String scriptsDirFullPath = getScriptssDirFullPath();

        this.scriptEngine = createScriptEngine();

        // Load JS scripts
        Path libsInitScriptPath = Paths.get(scriptsDirFullPath, "index.js");
        if (Files.exists(libsInitScriptPath)) {
            evalScriptFile(libsInitScriptPath.toString());
        }

        // Start querying the session status and executing the tests/steps
        while (this.currentTestSession != null) {
            SessionStatusResponse sessionStatus = null;

            try {
                sessionStatus = this.getTestSessionStatus();
            } catch (Exception ex) {
                Logger.error("A critical error has happened. Please provide all potentially relevant data to the dev team for a fix.", ex);
                //TODO: Continue implementation to cover all edge cases
                return;
            }

            // TODO: If the session status returns null for a longer time, abandon session
            if (sessionStatus != null) {
                if (sessionStatus.status.equals("started")) {
                    // Update the iteration number and reset current test, if necessary
                    if (this.currentTestSession.currentIteration < sessionStatus.currentIteration) {
                        this.currentTestSession.currentIteration = sessionStatus.currentIteration;
                        this.currentTestSession.currentTestIndex = -1;
                        this.currentTestSession.currentStepIndex = -1;
                        this.currentStepIsCompleted = false;
                    }

                    // Update the index of the current test for this actorType and
                    // load the test definition
                    if (this.currentTestSession.currentTestIndex < sessionStatus.currentTestIndex) {
                        this.currentTest = null;
                        this.currentTestSession.currentTestIndex = sessionStatus.currentTestIndex;
                        this.currentTestSession.currentTestPath = sessionStatus.currentTestPath;
                        this.currentTestSession.currentTestName = sessionStatus.currentTestName;
                        this.currentTestSession.currentStepIndex = -1;

                        log.info("--------------------------------------------------");
                        log.info(String.format("Actor %s started executing test %s/%s...",
                                this.actorType,
                                this.currentTestSession.currentTestPath,
                                this.currentTestSession.currentTestName));

                        // Identify and parse the test definition file
                        try {
                            this.currentTest = getTestDefinition(String.format("%s/%s",
                                    this.currentTestSession.currentTestPath,
                                    this.currentTestSession.currentTestName));
                            this.scriptEngine.put("$test", this.currentTest);
                        } catch (Exception ex) {
                            StringWriter sw = new StringWriter();
                            ex.printStackTrace(new PrintWriter(sw));
                            log.error((sw.toString()));

                            // Notify the sync service that step 0 of the test failed
                            HttpRequest stepStatusRequest = new HttpRequest(
                                    String.format("%s/api/session/%s/actor/%s/test/%s/step/%s",
                                            syncServiceBaseUrl,
                                            this.currentTestSession.id,
                                            actorId,
                                            this.currentTestSession.currentTestIndex,
                                            0),
                                    HttpVerb.PUT);

                            // Start step 0
                            stepStatusRequest.setContent("{\"status\":\"started\",\"result\":\"pending\"}", ContentType.APPLICATION_JSON);
                            stepStatusRequest.execute();

                            // Fail step 0
                            stepStatusRequest.setContent("{\"status\":\"completed\",\"result\":\"failed\"}", ContentType.APPLICATION_JSON);
                            stepStatusRequest.execute();
                        }
                    }

                    if (this.currentTestSession.currentTestIndex == sessionStatus.currentTestIndex) {
                        // Update the current step index for the actorType
                        if (this.currentTestSession.currentStepIndex < sessionStatus.currentStepIndex) {
                            this.currentTestSession.currentStepIndex = sessionStatus.currentStepIndex;
                            currentStepIsCompleted = false;
                        }

                        if (!currentStepIsCompleted && this.currentTestSession.currentStepIndex == sessionStatus.currentStepIndex) {
                            currentStepIsCompleted = true;
                            try {
                                executeTestStep(sessionStatus.currentStepIndex);
                            } catch (Exception ex) {
                                Logger.error(ex);
                            }
                        }
                    }
                } else if (sessionStatus.status.equals("completed")) {
                    log.info(String.format("Test session %s has completed\n", this.currentTestSession.id));
                    this.currentTestSession = null;
                }
            }

            try {
                Thread.sleep(1000);
            } catch (InterruptedException ex) {
            }
        }
    }

    @Override
    public void runOneSession() throws Exception {
        runOneSession(null);
    }

    private void startAnnounceThread() {
        stopAnnounceThread();

        announceThread = new Thread() {
            public void run() {
                while (!actorIsStopping) {
                    announce();
                    try {
                        Thread.sleep(5000);
                    } catch (InterruptedException ex) {
                        break;
                    }
                }
            }
        };

        log.info(String.format("Connecting to sync service at %s...", syncServiceBaseUrl));
        announceThread.start();
    }

    private void stopAnnounceThread() {
        if (announceThread != null) {
            announceThread.interrupt();
        }
    }

    private void takeScreenShot() {
        if (this.currentAction != null) {
            InputStream screenshotStream = this.currentAction.takeScreenshot();

            if (screenshotStream != null) {
                // TODO: Send screenshot to sync service
            }
        } else {
            // TODO: Uncomment the line below, when ready

            // We keep this commented for now because we always have step 0 with
            // no actions and we don't want warnings in the log file that don't
            // mean anything. When we eliminate step 0 we can uncomment this.
            // Logger.warning("There was an attempt to capture a screenshot, but the current action was null.");
        }
    }

    /**
     * Implementation of the $sharedData function exposed in JavaScript.
     */
    public class SharedDataFunction extends AbstractJSObject {

        public SharedDataFunction() {
        }

        @Override
        public boolean isFunction() {
            return true;
        }

        @Override
        public Object call(Object thiz, Object... args) {
            if (args.length == 1) {
                String url = String.format("%s/api/session/%s/test/%s/data",
                        syncServiceBaseUrl,
                        currentTestSession.id,
                        currentTestSession.currentTestIndex);

                try {
                    HttpRequest request = new HttpRequest(url, HttpVerb.GET);
                    request.execute();
                    String responseBody = request.getResponseAsString();
                    Map<String, Object> sharedData = new Gson().fromJson(responseBody, Map.class);
                    return sharedData.get(args[0]);
                } catch (Exception ex) {
                    throw new RuntimeException(String.format("There was an error while requesting the test shared data from the sync service. HTTP request details: %s",
                            "GET " + url));
                }
            } else if (args.length == 2) {
                try {
                    publishSharedData(args[0].toString(), args[1]);
                } catch (Exception ex) {
                    throw new RuntimeException(String.format(
                            "There was an error while publishing the test shared data to the sync service."), ex);
                }
            }

            return Undefined.getUndefined();
        }
    }
}
