import * as _ from 'underscore';
import * as configLoader from '../lib/configLoader';
import * as constants from '../lib/constants';
import { db, memDb } from '../lib/db';
import * as helpers from '../lib/helpers';
import * as logManager from '../lib/log-manager';
import * as  moment from 'moment';
import * as testRepo from '../lib/testRepo';
import { SessionTestActor, TestInfo, TestSessionProperties } from './types';

/** Create a test session according to the specified session properties object */
export async function createSession(template: TestSessionProperties): Promise<number> {
    template.maxIterations = template.maxIterations || 1;
    template.sessionLabel = template.sessionLabel || Math.round(Date.now()/1000).toString();;

    return new Promise<number>(async function (resolve, reject) {
        // Identify an available session ID
        let sessionId = Math.round(moment().valueOf() / 1000);
        while (await memDb.getMemSession(sessionId) != null) {
            ++sessionId;
        }

        // Create session logger
        let log = logManager.getSessionLog(sessionId);

        try {
            let testInfos: TestInfo[] = template.tests;
            testRepo.completeTestInfos(testInfos, testRepo.testInfos);

            let rawActors = [];
            let sessionTests = [];
            let config = configLoader.getConfig();

            testInfos.forEach(function (t) {
                rawActors = rawActors.concat(t.actors);
                let sessionTest = {
                    path: t.path,
                    name: t.name,
                    currentStepIndex: 0,
                    status: "pending",
                    steps: []
                };

                let maxStepIndex = Math.max.apply(null, t.steps);

                for (let stepIndex = 0; stepIndex <= maxStepIndex; ++stepIndex) {
                    sessionTest.steps.push({
                        index: stepIndex
                    });
                }

                sessionTests.push(sessionTest);
            });

            let requiredActors = _.union(rawActors).sort();
            let actorsInfo = requiredActors.map(function (a) {
                return { actorType: a, acquired: false };
            });

            let acquireActorsTimeout = config.acquireActorsTimeoutSec * 1000;
            let startAcquireTimeout = 1000;

            let startAquireTime = Date.now();

            await memDb.insertMemSession(sessionId, template.sessionLabel || sessionId.toString());
            await memDb.updateMemSession(sessionId, { iterations: template.maxIterations, tests: sessionTests });

            let startAcquireActorsTime = Date.now();
            let sessionActors = {};

            log.info(helpers.format('Acquiring actors for session {0} ({1})',
                sessionId,
                requiredActors.join(', ')));
            await acquireActors();

            resolve(sessionId);

            async function acquireActors() {
                //TODO: Check that the test session is not cancelled. If it is, free all acquired actors and return.
                let session = await memDb.getMemSession(sessionId);

                if (!session || session.status === constants.testSessionStatus.COMPLETED) {
                    return;
                }

                try {
                    // Identify available actors to run this test session
                    for (let a of actorsInfo) {
                        if (!a.acquired) {
                            let testActor = _.find(await memDb.getActorsByType(a.actorType), function (actor) {
                                return !actor.testSessionId;
                            });

                            if (testActor) {
                                await memDb.updateActor(testActor.id, { testSessionId: sessionId });
                                let dbActor = await memDb.getActor(testActor.id);
                                if (dbActor.testSessionId === sessionId) {
                                    let sessionActor: SessionTestActor = {
                                        ...testActor,
                                        tests: []
                                    };
                                    sessionActors[sessionActor.id] = sessionActor;
                                    a.acquired = true;
                                }
                            }
                        }
                    }

                    let allActorsAquired = actorsInfo.filter(function (a) { return !a.acquired; })[0] == undefined;
                    if (allActorsAquired) {
                        await startTestSession();
                    } else {
                        if (Date.now() - startAcquireActorsTime < acquireActorsTimeout) {
                            setTimeout(acquireActors, startAcquireTimeout);
                        }
                    }
                } catch (err) {
                    console.error(err, err.stack);
                }
            }

            async function cancelTestSession(sessionId) {
                await memDb.updateMemSession(sessionId, {
                    actors: sessionActors,
                    result: constants.testSessionResult.CANCELLED,
                    status: constants.testSessionStatus.COMPLETED,
                    timeCompleted: Date.now()
                });
            }

            async function startTestSession() {
                log.info(helpers.format('Session {0} ("{1}") started at {2} UTC',
                    sessionId,
                    template.sessionLabel,
                    moment().utc().format('YYYY-MM-DD HH:mm:ss')));

                await memDb.updateMemSession(sessionId, {
                    actors: sessionActors,
                    status: constants.testSessionStatus.STARTED
                });
            }
        } catch (err) {
            log.error(JSON.stringify(err));
            reject();
        }
    });
}